<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FanWalker&#39;s blog</title>
  <subtitle>成功，唯有积累，没有奇迹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fanwalker.com/"/>
  <updated>2017-11-18T07:42:23.416Z</updated>
  <id>http://fanwalker.com/</id>
  
  <author>
    <name>FanWalker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高性能网站建设指南学习总结</title>
    <link href="http://fanwalker.com/2017/10/30/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE%E5%AD%A6%E4%B9%A0/"/>
    <id>http://fanwalker.com/2017/10/30/高性能网站建设学习/</id>
    <published>2017-10-30T12:08:36.000Z</published>
    <updated>2017-11-18T07:42:23.416Z</updated>
    
    <content type="html"><![CDATA[<p>这篇总结是对高性能网站建设指南书籍做出的，以巩固所学知识。书中共介绍了14条提升性能的规则，在介绍这14条规则前，书本还提到了一种法则，叫做</p>
<p>性能黄金法则。</p>
<h2 id="性能黄金法则"><a href="#性能黄金法则" class="headerlink" title="性能黄金法则"></a>性能黄金法则</h2><p>只有10%~20%的最终用户响应时间花在了下载html文档上，其余的80%~90%时间花在了下载页面中的所有组件上。</p>
<h2 id="规则1—–-减少HTTP请求"><a href="#规则1—–-减少HTTP请求" class="headerlink" title="规则1—– 减少HTTP请求"></a>规则1—– 减少HTTP请求</h2><p>性能黄金法则中说到最终用户响应时间的80%~90%是花在HTML文档所引用的所有组件（图片、脚本、样式表、Flash等）的HTTP请求上，因此减少HTTP</p>
<p>请求数量是提升性能的最简单途径。减少HTTP请求的方法有：</p>
<a id="more"></a>
<h4 id="图片地图"><a href="#图片地图" class="headerlink" title="图片地图"></a>图片地图</h4><p>使用<strong>图片地图</strong>（Image Map）在一个图片上关联多个url，目标url的选择取决于用户点击了图片上的哪个位置，比如，本来五个图片关联五个url，现在将这五个</p>
<p>图片合并成一张图片上，这样就减少了四个HTTP请求。</p>
<p>缺点：</p>
<ul>
<li>手工很难定义图片地图上的区域坐标；</li>
<li>除了矩形之外几乎无法定义其他形状；</li>
<li>通过DHTML创建的图片地图在Internet Explorer中无法工作</li>
</ul>
<h4 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h4><p>CSS Sprites将多幅图片合并为一幅单独的图片，然后利用background-position进行定位显示特定图片，原理是借由减少下载图像文件数量，提高网页的显</p>
<p>示性能。</p>
<p>优点：</p>
<ul>
<li>通过合并图片减少HTTP请求，比图片地图更灵活，因为CSS Sprites没有限制图片必须是连续的；</li>
<li>降低了下载量，合并的图片比分离的图片的总和要小，因为它降低了图片自身的开销（颜色表、格式信息、等等）；</li>
</ul>
<p>缺点：</p>
<ul>
<li>后期修改麻烦，难以维护，牵一发动全身，没有之前改一个图片就好了容易</li>
</ul>
<h4 id="内联图片（Inline-Images）"><a href="#内联图片（Inline-Images）" class="headerlink" title="内联图片（Inline Images）"></a>内联图片（Inline Images）</h4><p>通过使用 <code>data:url</code> 模式 是web页面中包含图片，无需额外的HTTP请求。但Internet Explorer不支持这种方式。</p>
<blockquote>
<p>格式： <code>data:[&lt;mediatype][;base64],&lt;data&gt;</code></p>
<p>一般的写法：<code>&lt;img src=&quot;http://blog.xmaoseo.com/images/xmaoseo.jpg&quot;/&gt;</code></p>
<p>内联图片写法： <code>&lt;img src=&quot;data:image/png;base64,iVBOR....&gt;</code></p>
</blockquote>
<p>这里的<code>iVBOR....</code>是base64编码，还有<code>data:url</code>模式的缺陷是IE不支持，另一个可能存在数据大小上的限制，Firefox1.5可以支持高达100kb的内联图片。<br>Base64编码会增加图片的大小，因此整体下载量会增加。</p>
<p>这种模式下，在跨越不同页面时不会被缓存，不要去内联较大的图片，因为编码后会导致页面变大。好的做法是使用CSS并将内联图片作为背景。将该<br>CSS规则放在外部样式表中，数据可以缓存在样式表内部</p>
<p>使用PHP函数可以获取图片的base64编码，例子：</p>
<pre><code>.home{background-image: url(data:image/gif;base64,
  &lt;?php echo base64_encode(file_get_contents(&quot;../image/home.gif&quot;)) ?&gt;)}
</code></pre><h4 id="合并脚本和样式表"><a href="#合并脚本和样式表" class="headerlink" title="合并脚本和样式表"></a>合并脚本和样式表</h4><p>根据模块化原则， 我们应该将代码放到多个小文件中，但是这样会降低性能，因为每个文件都会导致一个额外的http请求。理想情况，一个页面不应该使用</p>
<p>多余一个的脚本和样式表。建议多个脚本合并为一个脚本，多个样式表也应该合并为一个样式表。</p>
<h2 id="规则2-—–-使用内容发布网络-（Use-a-Content-Delivery-Network）"><a href="#规则2-—–-使用内容发布网络-（Use-a-Content-Delivery-Network）" class="headerlink" title="规则2 —– 使用内容发布网络 （Use a Content Delivery Network）"></a>规则2 —– 使用内容发布网络 （Use a Content Delivery Network）</h2><p>内容分发网络（conten delivery network）是一组分布在多个不同地理位置的Web服务器。用于更加有效地向用户发布网络。</p>
<p>CDN优点：</p>
<blockquote>
<p>缩短相应时间，备份扩展存储能力和进行缓存，缓和WEB流量峰值压力(获取天气，娱乐体育新闻等等)</p>
</blockquote>
<p>CDN缺点：</p>
<blockquote>
<p>你的响应时间会受到其他网站——甚至是竞争对手的流量的影响。无法控制组件服务器所带来的特殊麻烦。比如，修改HHTP表头必须由服务提供商来完成。</p>
</blockquote>
<p>CDN用于发布静态图片（将所有静态组件转移到CDN），图片，脚本样式表，Flash，静态文件更易存储，有较少的依赖性。</p>
<h2 id="规则3-—–-添加Expires头"><a href="#规则3-—–-添加Expires头" class="headerlink" title="规则3 —– 添加Expires头"></a>规则3 —– 添加Expires头</h2><p>web页面都包含了大量的组件，并且其数量在不断增长，页面的初访者会进行很多HTTP请求，但通过使用一个长久的Expires头，可以使这些组件被缓存。</p>
<p>这会在后续的页面浏览中避免不必要的HTTP请求。长久的Expires头常用于图片，但应将其用在包括脚本、样式表和Flash等所有组件上。</p>
<h4 id="Expires头"><a href="#Expires头" class="headerlink" title="Expires头"></a>Expires头</h4><p>Web服务器使用Expires头来告诉web客服端它可以使用一个组件的当前副本，直到指定的时间为止。例子：</p>
<pre><code>Expires: Mon, 15 Apr 2024 20:00:00 GMT
</code></pre><p>它告诉浏览器该响应的有效期持续到2024年4月15日为止。</p>
<h4 id="Max-Age-和-mod-expires"><a href="#Max-Age-和-mod-expires" class="headerlink" title="Max-Age 和 mod_expires"></a>Max-Age 和 mod_expires</h4><p>Expires头的使用要求服务器和客户端的时钟要严格同步，另外，过期日期需要经常检查，并且一旦未来这一天到来了，还需要在服务器配置中提供一个新的<br>日期。HTTP1.1引入了Cache-Control头来克服这个限制。</p>
<p>Cache-Control使用max-age指令指定组件被缓存多久。以秒为单位定义一个更新窗。</p>
<p>Expires和Cache-Control max-age两者同时出现，max-age指令将重写Expires头。</p>
<p>mod_expires Apache模块可以使你通过ExpirsDefault指令以相对方式设置日期。</p>
<blockquote>
<p>ExpirsDefault ‘access plus 10 years’</p>
</blockquote>
<p>时间可以设置为年月日时分秒。它同时向响应中发送Expires头和max-age头。实际过期日期根据何时得到请求而变，但是max-age有优先权。时钟同步问题<br>和固定日期更新不用担心了。</p>
<h4 id="空缓存vs完整缓存"><a href="#空缓存vs完整缓存" class="headerlink" title="空缓存vs完整缓存"></a>空缓存vs完整缓存</h4><p>用户第一次访问你的网站时，它不会对HTTP请求的熟练产生任何影响。此时浏览器的缓存是空的。因此，其性能的改进取决于用户在访问你的页面时是否有<br>完整的缓存，使你的组件可缓存可以改善这些用户的响应时间。</p>
<p>在那些每日一次一更新的网站，带有完整缓存的页面浏览百分比很少。旅游网站，email网站中每个用户会话可能产生多次页面浏览，百分比就高。<br>只要用户每个月至少访问一次，或者每次会话产生多次页面浏览，完整缓存就很有用，使用长久Expires就很有必要。</p>
<h4 id="不仅仅是图片"><a href="#不仅仅是图片" class="headerlink" title="不仅仅是图片"></a>不仅仅是图片</h4><p>为图片使用长久的Expires头非常之普遍，但不仅限于图片，长久的Expires头应该包含任何不经常变化的组件，包括脚本、样式表和Flash组件。但是HTML<br>文档不应该使用，因为包含动态内容，每次都要更新。</p>
<p>大型网站，图片，样式表，脚本大部分都要缓存30天以上。但是经常需要变化的新闻图片等等，不应该使用。我们可以查看Last-Modifed中的值来看改变时<br>间以及频率。</p>
<h4 id="修订文件名"><a href="#修订文件名" class="headerlink" title="修订文件名"></a>修订文件名</h4><blockquote>
<p>使用长久的Expires缺点是 ：浏览器不会检查任何更新，直到过了过期日期。即使在服务器上更新了组件，浏览器因为缓存也不能获得最新组件。</p>
</blockquote>
<p>为了确保用户能获得更新过的组件，需要在所有HTML页面中修改组件的文件名。最有效的解决方案是修改其所有链接，这样。全新的请求将从原始服务器<br>下载最新的内容。</p>
<p>使用php等动态语言生成HTML页将很简单，为所有组件的文件名使用变量，使用这种方法，在页面中更新文件名只需要简单地在某个地方修改变量。Yahoo<br>经常将这一步作为生成过程的一部分——版本号嵌入在组件的文件名中（例如yahoo_2.0.6.js），而且在全局映射中修订过的文件名会自动更新。嵌入版本<br>号不仅可以改变文件名，还能在调试中更容易找到准确的源代码文件。</p>
<h2 id="规则4-—–-压缩组件"><a href="#规则4-—–-压缩组件" class="headerlink" title="规则4 —– 压缩组件"></a>规则4 —– 压缩组件</h2><p>规则1–3都是限制不必要的HTTP请求来减少响应时间，现在我们通过减少响应大小来减少响应时间。</p>
<h4 id="压缩是如何工作的"><a href="#压缩是如何工作的" class="headerlink" title="压缩是如何工作的"></a>压缩是如何工作的</h4><p>Web客户端可以通过HTTP请求中的Accept-Encoding头来表示对压缩的支持</p>
<blockquote>
<p>Accept-Encoding: gzip,deflate</p>
</blockquote>
<p>Web服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来压缩响应。Web服务器通过响应中的Content-Encoding头来通知Web客户端</p>
<blockquote>
<p>Content-Encoding: gzip</p>
</blockquote>
<p>gzip是目前最有效，最流行的压缩方法，免费模式，并被标准化为RFC 1952.（90%使用）</p>
<h4 id="压缩什么"><a href="#压缩什么" class="headerlink" title="压缩什么"></a>压缩什么</h4><p>很多网站会压缩HTML文档，值得压缩的内容包括脚本、样式表、XML和JSON在内的任何文本响应。图片和PDF不应该解压缩，因为已经被压缩了。再压缩<br>只会浪费CPU资源，还有可能会增加文件大小。</p>
<p>压缩的成本：服务器会花费额外的CPU周期来完成压缩，客户端要对压缩文件进行解压缩。要检测受益是否大于开销，需要考虑响应的大小，连接的带宽和<br>客户端服务器之间的Internet距离。</p>
<p>根据经验，通常对大于1KB或2KB的文件进行压缩。mod_gzip_minimum_file_size指令控制着希望压缩文件的最小值，默认值是500B。</p>
<h4 id="节省"><a href="#节省" class="headerlink" title="节省"></a>节省</h4><p>压缩之后能将响应数据量减少将近70%</p>
<h2 id="规则5-—–-将样式表放在顶部"><a href="#规则5-—–-将样式表放在顶部" class="headerlink" title="规则5 —– 将样式表放在顶部"></a>规则5 —– 将样式表放在顶部</h2><p>使用link标签将样式表放在文档head中</p>
<h4 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h4><p>将样式表放在文档底部会导致在浏览器中阻止内容逐步呈现。为避免当样式变化时重绘页面中的元素，浏览器会阻塞内容逐步呈现。在浏览器和用户等待位<br>于底部的样式表时，浏览器会延迟显示任何可视化组件，这一现象称为“白屏”</p>
<p>它只发生在Internet Explorer中，并且依赖于页面是如何加载的。当发生这种现象时，页面会完全空白，直到页面的所有内容同时涌上屏幕。</p>
<p>白屏现象源自于浏览器的行为</p>
<h4 id="无样式内容的闪烁（Flash-of-Unstyled-Content）"><a href="#无样式内容的闪烁（Flash-of-Unstyled-Content）" class="headerlink" title="无样式内容的闪烁（Flash of Unstyled Content）"></a>无样式内容的闪烁（Flash of Unstyled Content）</h4><p>无样式内容的闪烁简称FOUC，当样式被放在了底部，页面逐步加载时，文字首先显示，然后是图片，最后样式表被正确地下载并解析之后，已经呈现的文<br>字和图片要用新的样式重绘，这就是“无样式内容的闪烁”。</p>
<p>白屏是对FOUC问题的弥补，浏览器可以延迟呈现，直到所有的样式表都下载完成后，这就导致了白屏，反之，浏览器可以逐步呈现，但要承担闪烁的风险。</p>
<p>使用样式表时，页面逐步呈现会被阻止，直到所有样式表下载完成后，这就是将样式表移动文档HEAD中的原因。</p>
<h2 id="规则6-—–-将脚本放在底部"><a href="#规则6-—–-将脚本放在底部" class="headerlink" title="规则6 —– 将脚本放在底部"></a>规则6 —– 将脚本放在底部</h2><p>在使用脚本时，在脚本以下的内容，逐步呈现都被阻塞了。将脚本放在页面越靠下的地方，意味着越多的内容能够逐步呈现</p>
<p>脚本阻塞并行下载的原因：</p>
<ul>
<li>脚本可能使用doucument.write来修改页面内容，因此浏览器会等待，以确保页面能够恰当地布局；</li>
<li>保证脚本能够按照正确的顺序执行，如果脚本之间有依赖关系，不按照执行顺序会导致JavaScript错误</li>
</ul>
<h2 id="规则7-—–-避免CSS表达式"><a href="#规则7-—–-避免CSS表达式" class="headerlink" title="规则7 —– 避免CSS表达式"></a>规则7 —– 避免CSS表达式</h2><p>css表达式 expression方法被其他浏览器忽略，IE支持，这种方法虽然强大但是非常危险。<br>表达式求之的频率远高于人们的期望，不仅在页面呈现和大小改变时求值，鼠标拖拽，页面滚动时候都会求值。所以要避开css表达式，用事件处理器来为特定的事件提供所期望的动态行为。</p>
<h2 id="规则8-—–-使用外部JavaScript和CSS"><a href="#规则8-—–-使用外部JavaScript和CSS" class="headerlink" title="规则8 —– 使用外部JavaScript和CSS"></a>规则8 —– 使用外部JavaScript和CSS</h2><p>纯粹而言，内联JavaScript和CSS是比外置更快一些，因为外置的示例需要承担多个HTTP请求带来的开销。</p>
<h4 id="页面浏览量"><a href="#页面浏览量" class="headerlink" title="页面浏览量"></a>页面浏览量</h4><p>页面浏览量越多，外置实例越有优势，因为浏览器会缓存外部文件，这样就减少了HTTP请求，反之则内联更好</p>
<h4 id="组件重用"><a href="#组件重用" class="headerlink" title="组件重用"></a>组件重用</h4><p>如果使用相同的JavaScript和CSS，外部文件可以提高这些组件的重用率</p>
<h2 id="减少DNS查找"><a href="#减少DNS查找" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h2><p>DNS的开销：通常浏览器查找一个给定主机名的IP地址要话费20-120毫秒，在DNS查找完成前，浏览器不能从主机名那里下载到任何东西，响应时间依赖于<br>DNS解析器（通常有你的ISP提供）、它所承担的请求压力、你与它之间的距离和你的带宽速度。</p>
<h4 id="DNS缓存和TTL"><a href="#DNS缓存和TTL" class="headerlink" title="DNS缓存和TTL"></a>DNS缓存和TTL</h4><p>DNS查找可以被你的ISP或局域网中一台特殊的缓存服务器、用户计算机缓存起来，用户请求了一个主机名后，DNS信息会留在操作系统的DNS缓存中。<br>浏览器也拥有其缓存，和操作系统的缓存分离，DNS的查找顺序是：浏览器  ——&gt;  操作系统 ——&gt; 远程服务器</p>
<p>TTL（Time to live）：存活时间，服务器返回的DNS记录包含了一个存活时间，告诉客户端可以对该记录缓存多久</p>
<p>在HTTP请求中使用 Connection:keep-alive 来保持持久连接，持久连接的引入使得浏览器可以在一个单独的连接上进行多个请求，从而减少DNS查找。</p>
<h2 id="规则10-—–-精简JavaScript"><a href="#规则10-—–-精简JavaScript" class="headerlink" title="规则10 —– 精简JavaScript"></a>规则10 —– 精简JavaScript</h2><h4 id="精简"><a href="#精简" class="headerlink" title="精简"></a>精简</h4><p>从代码中减少不必要的字符包括空白字符、注释来减小js文件的大小，进而改善加载时间</p>
<h4 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h4><p>混淆是可以应用在源代码上的另外一种优化方式，和精简一样，也会移除注释和空白，作为改写的一部分，函数和变量的名字将被转换为更短的字符串。</p>
<ul>
<li>缺陷：混淆更加复杂，混淆过程本身很有可能引入错误。</li>
<li>维护： 由于混淆会改变js符号，因此需要对任何不能改变的符号（例如API函数）进行标记，防止混淆修改他们。</li>
<li>调试：很难阅读，调试更加困难。</li>
</ul>
<p>实际经过gzip压缩之后，精简和混淆差别很小。精简脚本可以降低响应时间，但不会带来混淆的风险。</p>
<h4 id="精简css"><a href="#精简css" class="headerlink" title="精简css"></a>精简css</h4><p>精简css带来的节省通常小于js,因为注释和空白比较少。最大的潜在节省来自于优化css——合并相同的类，移除不使用的类等。css依赖顺序的本质（成为层<br>叠样式表的原因）决定了这是一个复杂的问题。这个领域还需要进一步的研究和工具开发。</p>
<p>通常解决方案有使用颜色缩写，用“0”代替“0px”，用“#606”代替“#660066”。</p>
<h2 id="规则11-—–-避免重定向"><a href="#规则11-—–-避免重定向" class="headerlink" title="规则11 —– 避免重定向"></a>规则11 —– 避免重定向</h2><p>重定向用于将用户从一个URL重新路由到另一个URL，最常见的重定向为301和302，html文档、图片、脚本、样式表等都可以进行重定向，重定向会使你的<br>页面变慢。</p>
<p>重定向原因：</p>
<ul>
<li>网站重新设计</li>
<li>跟踪流量</li>
<li>记录广告点击</li>
<li>建立易于记忆的URL</li>
</ul>
<h4 id="重定向类型"><a href="#重定向类型" class="headerlink" title="重定向类型"></a>重定向类型</h4><p>web服务器向浏览器返回一个重定向时，响应中会有一个范围在3xx的状态码。</p>
<p>document.location可以设置期望的url实现重定向，还有meta refresh标签可以在content属性所指定的描述之后重定向用户-</p>
<pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0&quot;;url=http://stevesouders.com/newuri&quot;&gt;
</code></pre><h4 id="重定向如何损伤性能"><a href="#重定向如何损伤性能" class="headerlink" title="重定向如何损伤性能"></a>重定向如何损伤性能</h4><p>重定向延迟了整个HTML文档的传输，在HTML文档到达之前，页面中不会呈现出任何东西，也没有任何组件会被下载。</p>
<h4 id="重定向之外的其他选择"><a href="#重定向之外的其他选择" class="headerlink" title="重定向之外的其他选择"></a>重定向之外的其他选择</h4><ol>
<li>缺少结尾的斜线/：这是最为浪费和频繁的，也是web开发人员没注意的。没有/时会导致301响应，这是很多web服务器的默认行为，所以很简单，url后面加一个/</li>
<li>跟踪内部流量：分析离开网页首页之后的流量去向。使用referer。难处在于只能分析内部，自己公司的，如果目标网站属于其他公司则不可能分析referer日志了。</li>
<li>跟踪出站流量：用信标（beacon）——一个hppt请求，其URL中包含有跟踪信息。跟踪信息可以从信标web服务器的访问日志中提取出来。</li>
</ol>
<h2 id="规则12-—–-删除重复的脚本"><a href="#规则12-—–-删除重复的脚本" class="headerlink" title="规则12 —– 删除重复的脚本"></a>规则12 —– 删除重复的脚本</h2><p>来自不同团队的很多人都要向页面中添加HTML，有可能相同的脚本会被添加两次。</p>
<h4 id="重复脚本危害"><a href="#重复脚本危害" class="headerlink" title="重复脚本危害"></a>重复脚本危害</h4><p>不必要的HTTP请求和执行JavaScript所浪费的时间。</p>
<h2 id="规则13-—–-配置ETag"><a href="#规则13-—–-配置ETag" class="headerlink" title="规则13 —– 配置ETag"></a>规则13 —– 配置ETag</h2><p>ETag（Entity Tag）是Web服务器和浏览器用于确认缓存组件有效性的一种机制。ETag是一个字符串，它唯一标识了一个组件的特定版本。</p>
<p>原始服务器使用ETag响应头来指定组件的ETag，第一次请求：</p>
<pre><code>//请求：
GET /i/xx.jpg HTTP 1.1
HOST www.xxx.com
//响应：
HTTP 1.1 20 OK
Last-Modified:true .12 dec 2015 03:03:09 GMT
ETag:&quot;10c34ba-8ba-abds3b3&quot;
Content-Length:1024
</code></pre><p>第二次请求，验证组件是否有效，会使用If-None-Match头将ETag传回原始服务器。</p>
<pre><code>//请求：
GET /i/xx.jpg HTTP 1.1
HOST www.xxx.com
If-Modified-Since:True,12 dec 2015 03:03:09 GMT
If-None-Match:&quot;10c34ba-8ba-abds3b3&quot;
//响应：
HTTP 1.1 304 not modifed
</code></pre><h4 id="ETag带来的问题"><a href="#ETag带来的问题" class="headerlink" title="ETag带来的问题"></a>ETag带来的问题</h4><p>对于使用服务器集群来处理请求的网站，匹配次数会大大降低。此时etag就降低了缓存效率，导致了不必要的请求。If-None-Match的优先级比If-Modified-Since的优先级更高。</p>
<h4 id="ETag的使用"><a href="#ETag的使用" class="headerlink" title="ETag的使用"></a>ETag的使用</h4><p>一种选择对ETag进行配置，以利用其灵活的验证能力，可以使用php等脚本语言配置ETag头。</p>
<p>如果你的组件必须通过最新修改日期之外的一些东西来验证，使用ETag。</p>
<p>你还可以将ETag头安全移除在apache配置文件中，减少它的坏处。<br>从ETag中移除ChangeNumber或者完全移除ETag可以避免当数据已经位于浏览器缓存中时进行不必要的和低效的下载。</p>
<h2 id="规则14-—–-使Ajax可缓存"><a href="#规则14-—–-使Ajax可缓存" class="headerlink" title="规则14 —– 使Ajax可缓存"></a>规则14 —– 使Ajax可缓存</h2><blockquote>
<p>被动Ajax请求：是为了将来使用而预先发起的。</p>
<p>主动Ajax请求：基于用户当前的操作而引起的。</p>
</blockquote>
<p>主动请求对用户体验的影响更大，改善这些主动Ajax请求最重要的方式就是使响应可缓存。</p>
<p>使用一个长久的Expires头，将响应的个性化和动态本质反映到缓存中（可供采用的最好方式是使用查询字符串参数）</p>
<p>有的响应中因为数据隐私原因而不能缓存，当数据被认为是私有的时候，大多会在响应中使用 <code>Cache-Control:no-store</code>。<br>处理数据隐私的更好方法是使用安全通信协议如安全套接字层（Secure Socket Layer,SSL）。SSL响应式可以缓存的。</p>
<p><strong>到此高性能建站建设学习指南14大规则基本总结完</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇总结是对高性能网站建设指南书籍做出的，以巩固所学知识。书中共介绍了14条提升性能的规则，在介绍这14条规则前，书本还提到了一种法则，叫做&lt;/p&gt;
&lt;p&gt;性能黄金法则。&lt;/p&gt;
&lt;h2 id=&quot;性能黄金法则&quot;&gt;&lt;a href=&quot;#性能黄金法则&quot; class=&quot;headerlink&quot; title=&quot;性能黄金法则&quot;&gt;&lt;/a&gt;性能黄金法则&lt;/h2&gt;&lt;p&gt;只有10%~20%的最终用户响应时间花在了下载html文档上，其余的80%~90%时间花在了下载页面中的所有组件上。&lt;/p&gt;
&lt;h2 id=&quot;规则1—–-减少HTTP请求&quot;&gt;&lt;a href=&quot;#规则1—–-减少HTTP请求&quot; class=&quot;headerlink&quot; title=&quot;规则1—– 减少HTTP请求&quot;&gt;&lt;/a&gt;规则1—– 减少HTTP请求&lt;/h2&gt;&lt;p&gt;性能黄金法则中说到最终用户响应时间的80%~90%是花在HTML文档所引用的所有组件（图片、脚本、样式表、Flash等）的HTTP请求上，因此减少HTTP&lt;/p&gt;
&lt;p&gt;请求数量是提升性能的最简单途径。减少HTTP请求的方法有：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript之正则表达式</title>
    <link href="http://fanwalker.com/2017/10/21/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://fanwalker.com/2017/10/21/JavaScript之正则表达式/</id>
    <published>2017-10-21T14:33:11.000Z</published>
    <updated>2017-11-18T08:19:52.336Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>/正则表达式主体/修饰符(可选)
</code></pre><p>实例：</p>
<pre><code>var patt = /runoob/i
</code></pre><p>/runoob/i  是一个正则表达式。runoob  是一个正则表达式主体 (用于检索)。i  是一个修饰符 (表示搜索不区分大小写)。</p>
<a id="more"></a>
<h3 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h3><p>1、使用一个正则表达式字面量：</p>
<pre><code>/*
   pattern/flags 
*/

const regex = /ab+c/;

const regex = /^[a-zA-Z]+[0-9]*\W?_$/gi;/
</code></pre><p>在加载脚本后，正则表达式字面值提供正则表达式的编译。当正则表达式保持不变时，使用此方法可获得更好的性能。</p>
<p>2、调用RegExp对象的构造函数：</p>
<pre><code>/* 
    new RegExp(pattern , modifiers)  

    //pattern（模式） 描述了表达式的模式,modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配
*/
let regex = new RegExp(&quot;ab+c&quot;);
let regex = new RegExp(/^[a-zA-Z]+[0-9]*\W?_$/, &quot;gi&quot;);
let regex = new RegExp(&quot;^[a-zA-Z]+[0-9]*\\W?_$&quot;, &quot;gi&quot;);  //注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）
</code></pre><h3 id="编写一个正则表达式的模式"><a href="#编写一个正则表达式的模式" class="headerlink" title="编写一个正则表达式的模式"></a>编写一个正则表达式的模式</h3><h4 id="使用简单的模式"><a href="#使用简单的模式" class="headerlink" title="使用简单的模式"></a>使用简单的模式</h4><p>简单的模式是由简单字符串所构成的。比如，/abc/这个模式就匹配了在一个字符串中，仅仅字符 ‘abc’ 同时出现并按照这个顺序。</p>
<h4 id="使用特殊字符"><a href="#使用特殊字符" class="headerlink" title="使用特殊字符"></a>使用特殊字符</h4><p>当你需要搜索一个比直接匹配需要更多条件的匹配时，比如寻找一个或多个 ‘b’，或者寻找空格，那么这时模式将要包含特殊字符。比如， 模式/ab*c/匹配了</p>
<p>一个单独的 ‘a’ 后面跟了零个或者多个 ‘b’（*的意思是前面一项出现了零个或者多个），且后面跟着 ‘c’ 的任何字符组合。在字符串 “cbbabbbbcdebc” 中，这</p>
<p>个模式匹配了子字符串 “abbbbc”。</p>
<h4 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h4><p>正则表达式可以被用于RegExp的exec和test方法以及 String的match、replace、search和split方法。</p>
<p>exec()：搜索符合规则的内容，并返回内容，格式为数组。</p>
<pre><code>var testStr = &quot;now test001 test002&quot;;   
var re = /test(\d+)/; //只匹配一次     
var r = &quot;&quot;;   
var r = re.exec(testStr)
alert(r);// test001  001 返回匹配结果，以及子项
alert(r.length); //2   返回内容的长度
alert(r.input); //now test001 test002    代表每次匹配成功的字符串 
alert(r[0]);   //test001   
alert(r[1]);  //001    代表每次匹配成功字符串中的第一个子项 (\d+) 
alert(r.index );   //  4   每次匹配成功的字符串中的第一个字符的位置
</code></pre><p>全局匹配，可以通过while循环 找到每次匹配到的字符串，以及子项。每次匹配都接着上次的位置开始匹配：</p>
<pre><code> var testStr = &quot;now test001 test002&quot;;   
 var re = /test(\d+)/g;    
 var r = &quot;&quot;;   

//匹配两次 每次匹配都接着上一次的位置开始匹配，一直匹配到最后r就为false,就停止匹配了 匹配到test001 test002  
while(r = re.exec(testStr)){
    alert(r);//返回每次匹配成功的字符串，以及子项，分别弹出 ：test001 001,test002  002
    alert(r.input); //分别弹出：   now test001 test002    now test001 test002  
    alert(r[0]);   //代表每次匹配成功的字符串  分别弹出：  test001     test002
    alert(r[1]);  //代表每次匹配成功字符串中的第一个子项 (\d+)  分别弹出：001   002
    alert(r.index );   // 每次匹配成功的字符串中的第一个字符的位置，分别弹出：4  12
    alert(r.length); //分别弹出：2   2
}
</code></pre><p>test() ：在字符串中查找符合正则的内容，若查找到返回true,反之返回false。</p>
<pre><code>var str = &apos;374829348791&apos;;
var re = /\D/;      //  \D代表非数字
if( re.test(str) ){   // 返回true,代表在字符串中找到了非数字。
    alert(&apos;不全是数字&apos;);
}else{
    alert(&apos;全是数字&apos;);
}
</code></pre><p>match()：在字符串中搜索复合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null。</p>
<pre><code>var str = &apos;abc&apos;;

var re = /(a)(b)(c)/;

alert( str.match(re) );  //[abc,a,b,c]( 返回的是匹配结果 以及每个子项  当match不加g的时候才可以获取到子项的集合)
</code></pre><p>replace()：查找符合正则的字符串，替换掉匹配的子字符串。返回替换后的内容。</p>
<pre><code>var str = &quot;我爱北京天安门，天安门上太阳升。&quot;;
var re = /北京|天安门/g;  //  找到北京 或者天安门 全局匹配
var str2 = str.replace(re,&apos;*&apos;); 
alert(str2)  //我爱**，*上太阳升 
</code></pre><p>search()：在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置），如果搜索失败就返回 -1 </p>
<pre><code>var str = &apos;abcdef&apos;;

var re = /B/i;

//var re = new RegExp(&apos;B&apos;,&apos;i&apos;); 也可以这样写

alert( str.search(re) ); // 1
</code></pre><h4 id="正则表达式中的特殊字符"><a href="#正则表达式中的特殊字符" class="headerlink" title="正则表达式中的特殊字符"></a>正则表达式中的特殊字符</h4><pre><code>[] ： 表示某个集合中的任意一个，比如 [abc] 整体代表一个字符 匹配 a b c 中的任意一个，也可以是范围，[0-9] 范围必须从小到大 。

[^a] ：^写在[]里面的话，就代表排除的意思

\s : 空格

\S : 非空格

\d : 数字

\D : 非数字

\w : 字符 ( 字母 ，数字，下划线_ )

\W : 非字符

.  : 任意字符

\. : 真正的点

\b : 匹配一个词的边界，独立的部分 （ 起始，结束，空格 ），如：/\bm/匹配“moon”中得‘m’，/oo\b/并不匹配&quot;moon&quot;中得&apos;oo&apos;，因为&apos;oo&apos;被一个词汇字符&apos;n&apos;紧跟着。

\B : 非独立的部分

\a : 表示重复的某个子项。比如：\1 : 重复的第一个子项；\2 : 重复的第二个子项。
</code></pre><p>例子（笔试题经常出现）：找重复项最多的字符个数</p>
<pre><code>var str = &apos;assssjdssskssalsssdkjsssdss&apos;;

var arr = str.split(&apos;&apos;); //把字符串转换为数组
str = arr.sort().join(&apos;&apos;); //首先进行排序，这样结果会把相同的字符放在一起，然后再转换为字符串
//alert(str);  // aaddjjkklsssssssssssssssss

var value = &apos;&apos;;
var index = 0; 
var re = /(\w)\1+/g;  //匹配字符，且重复这个字符，重复次数至少一次。
str.replace(re,function($0,$1){ 
    console.log($0);  //代表每次匹配成功的结果 : aa dd jj kk l sssssssssssssssss
    //alert($1);  代表每次匹配成功的第一个子项，也就是\w:  a d j k l S 
　　
    if(index&lt;$0.length){  //如果index保存的值小于$0的长度就进行下面的操作
        index = $0.length;  // 这样index一直保存的就在最大的长度
        value = $1;  //value保存的是出现最多的这个字符
    }

}); 

console.log(&apos;最多的字符:&apos;+value+&apos;,重复的次数:&apos;+index);  // s   17
</code></pre><h5 id="量词：代表出现的次数"><a href="#量词：代表出现的次数" class="headerlink" title="量词：代表出现的次数"></a>量词：代表出现的次数</h5><pre><code>{n,m}：至少出现n次，最多m次

{n,} :至少n次

 *   :任意次 相当于{0,}

 ?   :零次或一次 相当于{0,1}

 +   :一次或任意次相当于 {1,}

{n}  :正好n次

 ^   :放在正则的最开始位置，就代表起始的意思，注意  /[^a] /   和   /^[a]/是不一样的，前者是排除的意思，后者是代表首位。

 $   :正则的最后位置 , 就代表结束的意思
</code></pre><p>例子：判断是不是QQ号</p>
<pre><code>/*首先想QQ号的规则 
  1 首位不能是0 
  2 必须是 5-12位的数字
*/
var aInput = document.getElementsByTagName(&apos;input&apos;);

var re = /^[1-9]\d{4,11}$/;

//123456abc为了防止出现这样的情况，所以必须限制最后
//首位是0-9，接着是4-11位的数字类型。

aInput[1].onclick = function(){
    if( re.test(aInput[0].value) ){
        alert(&apos;是QQ号&apos;);
    }else{
        alert(&apos;不是QQ号&apos;);
    }
};
</code></pre><p>例子：去掉前后空格</p>
<pre><code>var str = &apos;  hello  &apos;;

alert( &apos;(&apos;+trim(str)+&apos;)&apos; );//为了看出区别所以加的括号。 (hello)

function trim(str){
  var re = /^\s+|\s+$/g; // |代表或者   \s代表空格  +至少一个    前面有至少一个空格 或者后面有至少一个空格 且全局匹配
  return str.replace(re,&apos;&apos;); //把空格替换成空
}
</code></pre><h4 id="常用的一些表单校验"><a href="#常用的一些表单校验" class="headerlink" title="常用的一些表单校验"></a>常用的一些表单校验</h4><pre><code>匹配中文：[\u4e00-\u9fa5] //中文ACALL码的范围
行首行尾空格：^\s*|\s*$ //首行出现任意个空格或者尾行出现任意个空格（任意表示也可以没有空格）

Email：^\w+@[a-z0-9]+(\.[a-z]+){1,3}$  
/*起始至少为一个字符(\w字母，数字或者下划线)，然后匹配@,接着为任意个字母或者数字，\.代表真正的点，.后面为至少一个的字符（a-z）,
同时这个(比如.com)整体为一个子项作为结束，可以出现1-3次。因为有的邮箱是这样的.cn.net。（xxxx.@qq.com xxxx.@163.com xxxx.@16.cn.net ）*/

网址：[a-zA-z]+://[^\s]*   http://......
  //匹配不分大小写的任意字母，接着是//,后面是非空格的任意字符

邮政编码：[1-9]\d{5}  //起始数字不能为0，然后是5个数字
身份证：[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x
</code></pre><h4 id="学习参考："><a href="#学习参考：" class="headerlink" title="学习参考："></a>学习参考：</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="external">正则表达式 - JavaScript | MDN</a></p>
<p><a href="http://www.cnblogs.com/moqing/archive/2016/07/13/5665126.html" target="_blank" rel="external">过目不忘JS正则表达式</a> <em>by 沫晴的前端世界</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。&lt;/p&gt;
&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/正则表达式主体/修饰符(可选)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var patt = /runoob/i
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;/runoob/i  是一个正则表达式。runoob  是一个正则表达式主体 (用于检索)。i  是一个修饰符 (表示搜索不区分大小写)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://fanwalker.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>自适应网页设计</title>
    <link href="http://fanwalker.com/2017/09/20/%E8%87%AA%E9%80%82%E5%BA%94%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    <id>http://fanwalker.com/2017/09/20/自适应网页设计/</id>
    <published>2017-09-20T13:24:59.000Z</published>
    <updated>2017-11-18T08:21:38.974Z</updated>
    
    <content type="html"><![CDATA[<p>自适应网页设计：让同一张网页自动适应不同大小的屏幕，根据屏幕宽度，自动调整布局的设计。</p>
<h2 id="一、viewport元标签"><a href="#一、viewport元标签" class="headerlink" title="一、viewport元标签"></a>一、viewport元标签</h2><p>在网页代码的头部，加入一行viewport元标签。</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;
</code></pre><p>代码意思是网页宽度默认等于设备的屏幕宽度，原始缩放比例为1.0，即网页的初始大小占屏幕的100%。</p>
<a id="more"></a>
<p>viewport设置属性如下：</p>
<blockquote>
<p>width：网页宽度，可设定数值或指定为device-width；</p>
<p>height：网页高度，可设定数值或指定为device-height；</p>
<p>initial-scale：第一次进入页面的初始比例；</p>
<p>minimum-scale：允许缩小最小比例；</p>
<p>maximum-scale：允许放大最大比例；</p>
<p>user-scalable：是否允许使用者缩放，值为1或0（yes or no）</p>
</blockquote>
<p>编译过程中会转化成如下语义：</p>
<pre><code>@viewport {
    width: device-width;
    initial-scale: 1.0
}
</code></pre><p>对于老式浏览器（IE6、7、8）：</p>
<pre><code>&lt;!--[if lt IE 9]&gt;
&lt;script src=&quot;http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js&quot;&gt;&lt;/script&gt;
&lt;![endif]--&gt;
</code></pre><h2 id="二、不要使用绝对宽度"><a href="#二、不要使用绝对宽度" class="headerlink" title="二、不要使用绝对宽度"></a>二、不要使用绝对宽度</h2><p>为了让网页根据屏幕宽度调整布局，不要使用绝对宽度的元素，如：</p>
<pre><code>width: 100px;
</code></pre><p>使用百分比宽度，如：</p>
<pre><code>width: 50%  （或 width: auto）
</code></pre><h2 id="三、相对大小的字体"><a href="#三、相对大小的字体" class="headerlink" title="三、相对大小的字体"></a>三、相对大小的字体</h2><p>字体使用相对大小（em）。</p>
<pre><code>body{
    font: normal 100% Helvetica, Arial, sans-serif;
}
</code></pre><p>上面代码指定，字体大小是页面默认大小的100%，即16像素。</p>
<pre><code>h1 {
　  font-size: 1.5em; 
}
</code></pre><p>h1的大小是默认大小的1.5倍，即16*1.5=24像素</p>
<pre><code>small {
　　font-size: 0.875em;
}
</code></pre><p>small元素的大小是默认大小的0.875倍，即14像素（16*0.875）。</p>
<p><strong>这里顺便补一下CSS单位px、pt、em、rem、vh、vw、vmin、vmax，因为在今年欢聚时代的校招笔试中也考到了</strong></p>
<h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>为像素单位。是屏幕上显示数据的最基本的点。</p>
<h3 id="pt"><a href="#pt" class="headerlink" title="pt"></a>pt</h3><p>pt是point，是印刷行业常用单位，等于1/72英寸。</p>
<h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px）。如当前对行内文本的字体尺寸未被人为设置，</p>
<p>则相对于浏览器的默认字体尺寸。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。</p>
<p><strong>简化font-size的换算</strong>：需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说</p>
<p>只需要将你的原来的px数值除以10，然后换上em作为单位就行了。</p>
<h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>相对单位，可理解为“root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。相对于当前对象内文本的字体尺寸。</p>
<pre><code>&lt;body&gt;
&lt;div class=&quot;div1&quot;&gt;
    &lt;div class=&quot;div2&quot;&gt;
          &lt;div class=&quot;div3&quot;&gt;div3&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre><p>样式：</p>
<pre><code>.div3{
    font-size:1.5rem;
}
</code></pre><p>此时div3的font-size =  1.5  *  （html的font-size）</p>
<h3 id="vh和vw"><a href="#vh和vw" class="headerlink" title="vh和vw"></a>vh和vw</h3><p>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。</p>
<p>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</p>
<p>如：</p>
<pre><code>浏览器高度900px，宽度为750px

1 vh = 900px * 1% = 9 px，1vw = 750px * 1% = 7.5 px。
</code></pre><p>这样就很容易实现与同屏幕等高的框：</p>
<pre><code>.slide { height: 100vh;} 
</code></pre><p>设置一个和屏幕同宽的标题，</p>
<pre><code>h1{font-size:100vw}
</code></pre><p>那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果。</p>
<h3 id="vmin-和-vmax"><a href="#vmin-和-vmax" class="headerlink" title="vmin 和 vmax"></a>vmin 和 vmax</h3><p>vmin：vw和vh中较小的那个。</p>
<p>vmax：vw和vh中较大的那个。</p>
<p>比如，浏览器的宽度设置为</p>
<pre><code>width:1200px;
height:800px; 
1vmax = 1200/100px = 12px;
1vmin = 800/100px = 8px;
</code></pre><p>如果:</p>
<pre><code>width:600px;
height:1080px;
 1vmin就等于6px, 1vmax则为10.8px。
</code></pre><p>有一个元素，你需要让它始终在屏幕上可见：</p>
<pre><code>.box { 
    height: 100vmin; 
    width: 100vmin;
}
</code></pre><p>如果你要让这个元素始终铺满整个视口的可见区域：</p>
<pre><code>.box { 
    height: 100vmax; 
    width: 100vmax;
}
</code></pre><h2 id="四、流动布局"><a href="#四、流动布局" class="headerlink" title="四、流动布局"></a>四、流动布局</h2><p>流动布局中各个区块的位置都是浮动的。</p>
<pre><code>.main { float: right; width: 70%; } 

.leftBar { float: left; width: 25%; } 
</code></pre><p>如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。</p>
<h2 id="五、选择加载CSS"><a href="#五、选择加载CSS" class="headerlink" title="五、选择加载CSS"></a>五、选择加载CSS</h2><p>运用 Css3 <a href="https://www.w3.org/TR/CSS21/media.html" target="_blank" rel="external">Media Queries</a>，根据不同的屏幕分辨率，选择应用不同的CSS规则：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;
　　　　media=&quot;screen and (max-device-width: 400px)&quot;
　　　　href=&quot;tinyScreen.css&quot; /&gt;
     }
</code></pre><p>上面的代码意思是，如果屏幕宽度小于400像素（max-device-width: 400px），就加载tinyScreen.css文件，</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;
　　　　media=&quot;screen and (min-width: 400px) and (max-device-width: 600px)&quot;
　　　　href=&quot;smallScreen.css&quot; /&gt;
</code></pre><p>如果屏幕宽度在400像素到600像素之间，则加载smallScreen.css文件。</p>
<p>除了用html标签加载CSS文件，还可以在现有CSS文件中加载。</p>
<pre><code>@import url(&quot;tinyScreen.css&quot;) screen and (max-device-width: 400px);
</code></pre><h2 id="六、CSS的-media规则"><a href="#六、CSS的-media规则" class="headerlink" title="六、CSS的@media规则"></a>六、CSS的@media规则</h2><p>同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。</p>
<pre><code>@media screen and (max-device-width: 400px) {
　　.column {
　　　　float: none;
　　　　width:auto;
　　　}
　　#sidebar {
　　　　display:none;
　　}
}
</code></pre><p>如果屏幕宽度小于400像素，则column块取消浮动（float:none）、宽度自动调节（width:auto），sidebar块不显示（display:none）。</p>
<h2 id="七、图片自适应"><a href="#七、图片自适应" class="headerlink" title="七、图片自适应"></a>七、图片自适应</h2><pre><code>img { max-width: 100%;}
</code></pre><p>老版本的IE</p>
<pre><code>img { width: 100%;}
</code></pre><h2 id="学习参考文章："><a href="#学习参考文章：" class="headerlink" title="学习参考文章："></a>学习参考文章：</h2><p><a href="http://www.ruanyifeng.com/blog/2012/05/responsive_web_design.html" target="_blank" rel="external">自适应网页设计（Responsive Web Design）</a></p>
<p><a href="http://www.alloyteam.com/2015/04/zi-shi-ying-she-ji-yu-xiang-ying-shi-wang-ye-she-ji-qian-tan/" target="_blank" rel="external">自适应设计与响应式网页设计</a></p>
<p><a href="http://blog.csdn.net/javaloveiphone/article/details/51120476" target="_blank" rel="external">搞清楚CSS单位px、em、rem、vh、vw、vmin、vmax</a></p>
<p><a href="https://banyaner.github.io/h5/html5/2015/08/05/Rem.html" target="_blank" rel="external">px,em,rem,vh,vw,vmin,vmax的区别及移动端字体自适应问题</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自适应网页设计：让同一张网页自动适应不同大小的屏幕，根据屏幕宽度，自动调整布局的设计。&lt;/p&gt;
&lt;h2 id=&quot;一、viewport元标签&quot;&gt;&lt;a href=&quot;#一、viewport元标签&quot; class=&quot;headerlink&quot; title=&quot;一、viewport元标签&quot;&gt;&lt;/a&gt;一、viewport元标签&lt;/h2&gt;&lt;p&gt;在网页代码的头部，加入一行viewport元标签。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码意思是网页宽度默认等于设备的屏幕宽度，原始缩放比例为1.0，即网页的初始大小占屏幕的100%。&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://fanwalker.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>浅谈CORS跨域资源共享</title>
    <link href="http://fanwalker.com/2017/09/10/%E6%B5%85%E8%B0%88CORS%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    <id>http://fanwalker.com/2017/09/10/浅谈CORS跨域资源共享/</id>
    <published>2017-09-10T14:30:18.000Z</published>
    <updated>2017-11-18T08:21:34.706Z</updated>
    
    <content type="html"><![CDATA[<p><strong>AJAX(Asynchronous JavaScript And Xml) 是JavaScript执行异步网络请求</strong></p>
<p>用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，web的运作原理：一次HTTP请求对应一个页面<br>要让用户留在当前页面，同时发送请求，要用JavaScript实现，接收到数据后，再用JavaScript更新页面</p>
<p>实现AJAX主要依靠XMLHttpRequest对象：</p>
<pre><code>function success(text){
  var textarea = document.getElementById(&apos;response-text&apos;);
  textarea.value = text;
}
function fail(err){
  var textarea = document.getElementById(&apos;response-text&apos;);
  text.value = &apos;Error:&apos; + err;
}
var xhr = new XMLHttpRequest();  //创建XMLHttpRequest对象
</code></pre><a id="more"></a>
<p>必须在调用open之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性</p>
<pre><code>xhr.onreadystatechange = function(){    //监测状态变化
  if(xhr.readyState == 4){  //状态为4时代表请求完成
    if(xhr.status === 200){   //响应已经成功返回
      return success(xhr.responseText);
    }else{
      return fail(xhr.status);
    }  
  }
  else{
    console.log(&apos;HTTP请求还在继续&apos;);
  }
}
xhr.open(&apos;get&apos;,url); 
xhr.send();
</code></pre><p>IE以及低版本IE,XMR对象是通过MSXML库中的一个ActiveX对象实现的。<br>所以在IE中可能会遇到三种不同的XHR对象：<br>MSXML2.XMLHttp、MSXML2.XMLHttp.3.0、MSXML2.XMLHttp.6.0<br>所以封装一个函数来创建XHR对象，兼容IE版本</p>
<pre><code>function createXHR(){
  if(typeof XMLHttpRequest != &quot;undefined&quot;){
    return new XMLHttpRequest();
  }else if(typeof ActiveXObject != &quot;undefined&quot;){
    if(typeof arguments.callee.activeXString != &quot;string&quot;){
      var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;, &quot;MSXML2.XMLHttp&quot;],
          i, len;
      for(i=0, len=versions.length; i&lt;len; i++){
        try{
          new ActiveXObject(versions[i]);
          arguments.callee.activeXString = versions[i];
          break;
        }catch(ex){
          console.log(ex);
        }
      }
    }
    return new ActiveXObject(arguments.callee.activeXString);
  }
}
var xhr = createXHR();
</code></pre><h3 id="CORS-Cross-Origin-Resource-Sharing-跨域资源共享"><a href="#CORS-Cross-Origin-Resource-Sharing-跨域资源共享" class="headerlink" title="CORS(Cross-Origin Resource Sharing)跨域资源共享"></a>CORS(Cross-Origin Resource Sharing)跨域资源共享</h3><p>Ajax同信限制：跨域安全策略；<br>XHR对象只能访问与包含它的页面位于同一个域中的资源：<br>1、域名要相同（www.example.com和example.com不同），<br>2、协议要相同（http和https不同），<br>3、端口号要相同（默认是:80端口，它和:8080就不同）。<br>CORS定义了在访问跨域资源时，浏览器和服务器应该怎样沟通，CORS的思想是使用自定义的HTTP头部让浏览器与服务区进行沟通，从而决定响应是成功还是失败<br>   比如一个简单的GET或POST请求，它没有自定义的头部，而主题内容是text/plain。在发送该请求时需要给它加一个额外的头部，包含请求页面的源信息（协议、域名和端口），服务器根据该头部信息决定是否给予响应，Origin头部示例：<br><code>Origin : http://www.fanwalker.com</code><br>如果服务器接收该请求，会在Access-Control-Allow-Origin头部中回发相同的源信息。例如：<br><code>Acess-Control-Allow-Origin: http://www.fanwalker.com</code><br>如果没有这个头部或不匹配源信息，浏览器会驳回请求。这里注意请求和响应都不包含cookie信息</p>
<h3 id="IE对CORS的实现"><a href="#IE对CORS的实现" class="headerlink" title="IE对CORS的实现"></a>IE对CORS的实现</h3><p>IE8中引入了XDR(XDomainRequest)类型，可以实现安全的跨域通信，XDR对象的使用方法与XHR对象相似：</p>
<p>GET请求</p>
<pre><code>var xdr = new XDomainRequest();
xdr.onload = function(){
      alert(xdr.responseText);    //xdr.responseText保存着响应数据
}
xdr.onerror = function(){       //失败后出发error事件
      alert(&quot;an error occurred.&quot;);
}
xdr.timeout = 1000;     //支持timeout属性和ontimeout事件处理程序，1秒钟后超时并调用ontimeout方法
xdr.ontimeout = function(){
      alert(&quot;Request took too long&quot;);
}
xdr.open(&quot;get&quot;, &quot;http://www.fanwalker.com/page/&quot;);
xdr.send(null);
</code></pre><p>POST请求</p>
<pre><code>var xdr = new XDomainRequest();
xdr.onload = function(){
      alert(xdr.responseText);    //xdr.responseText保存着响应数据
}
xdr.onerror = function(){       //失败后出发error事件
      alert(&quot;an error occurred.&quot;);
}
xdr.timeout = 1000;     //支持timeout属性和ontimeout事件处理程序，1秒钟后超时并调用ontimeout方法
xdr.ontimeout = function(){
      alert(&quot;Request took too long&quot;);
}
xdr.open(&quot;post&quot;, &quot;http://www.fanwalker.com/page/&quot;);
xdr.contentType = &quot;application/x-www-form-urlencoded&quot;:    //设置contentType属性表示发送数据的格式
xdr.send(null);
</code></pre><p>更多详细的介绍：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">HTTP访问控制（CORS）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;AJAX(Asynchronous JavaScript And Xml) 是JavaScript执行异步网络请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，web的运作原理：一次HTTP请求对应一个页面&lt;br&gt;要让用户留在当前页面，同时发送请求，要用JavaScript实现，接收到数据后，再用JavaScript更新页面&lt;/p&gt;
&lt;p&gt;实现AJAX主要依靠XMLHttpRequest对象：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function success(text){
  var textarea = document.getElementById(&amp;apos;response-text&amp;apos;);
  textarea.value = text;
}
function fail(err){
  var textarea = document.getElementById(&amp;apos;response-text&amp;apos;);
  text.value = &amp;apos;Error:&amp;apos; + err;
}
var xhr = new XMLHttpRequest();  //创建XMLHttpRequest对象
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="ajax" scheme="http://fanwalker.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之命名函数表达式</title>
    <link href="http://fanwalker.com/2017/08/30/JavaScript%E4%B9%8B%E5%91%BD%E5%90%8D%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://fanwalker.com/2017/08/30/JavaScript之命名函数表达式/</id>
    <published>2017-08-30T12:03:03.000Z</published>
    <updated>2017-11-18T08:20:52.249Z</updated>
    
    <content type="html"><![CDATA[<p>所谓命名函数表达式就是被赋予了名字的函数表达式，和它相对的是匿名函数，从简单的角度来看，命名函数表达式可以在调试器或性能分析程序中描述函</p>
<p>数的名称，在调试过程中有着不小的作用，因为通常在跨浏览器开发中都会出现一些小毛病，命名函数表达式可以帮助我们解决它们。</p>
<p>先来看一下函数表达式与函数声明以及现代调试器如何处理它们之类的内容。</p>
<h2 id="函数表达式与函数声明"><a href="#函数表达式与函数声明" class="headerlink" title="函数表达式与函数声明"></a>函数表达式与函数声明</h2><p>通常，我们可以通过函数表达式与函数声明来创建函数对象的方法。但是具体来说什么是函数表达式、什么是函数声明呢？在ECMA规范中明确了一点，函</p>
<p>数声明必须始终带有标志符——即函数名，而函数表达式可以省略这个标识符，如：<br><a id="more"></a></p>
<pre><code>//函数声明
function 函数名称(参数:可选){ 函数体 }

//函数表达式
function 函数名称（可选）(参数:可选){ 函数体 }
</code></pre><p>但是如果函数表达式没有省略函数名，这时候函数声明与函数表达式就容易混淆。这时候ECMAScript是通过上下文来区分两者。比如，function foo(){} 是一</p>
<p>个赋值表达式的一部分，则认为它是一个函数表达式，如果 function foo(){} 被包含在一个函数体内，或者位于程序（的最上层）中，则将它作为一个函数声</p>
<p>明来解析：</p>
<pre><code>function foo(){}; // 声明，因为它是程序的一部分

var bar = function foo(){}; // 表达式，因为它是赋值表达式（AssignmentExpression）的一部分

new function bar(){}; // 表达式，因为它是New表达式（NewExpression）的一部分

(function(){
   function bar(){}; // 声明，因为它是函数体（FunctionBody）的一部分
})();
</code></pre><p>还有一种就是被包含在一对圆括号中的函数—— (function foo(){})。将这种形式看成表达式同样是因为上下文的关系：’(‘ 和 ‘)’构成一个分组操作符，而分组</p>
<p>操作符只能包含表达式：</p>
<pre><code>function foo(){}; // 函数声明

(function foo(){}); // 函数表达式：注意它被包含在分组操作符中

try {
  (var x = 5); // 分组操作符只能包含表达式，不能包含语句（这里的var就是语句）
} catch(err) {
  // SyntaxError
}
</code></pre><p>在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：eval(‘(‘ + json + ‘)’)，这样做的原因就是因为分组操作符，也就是这对括号，</p>
<p>‘(‘ 和 ‘)’会让解析器强制将JSON的花括号解析成表达式而不是代码块。</p>
<pre><code>try {
  { &quot;x&quot;: 5 }; // &quot;{&quot; 和 &quot;}&quot; 会被解析成代码块
} catch(err) {
  // SyntaxError
}

({ &quot;x&quot;: 5 }); // 分组操作符强制将&quot;{&quot; 和 &quot;}&quot;作为对象字面量来解析
</code></pre><p>声明和表达式的行为存在着十分微妙而又十分重要的差别。首先，函数声明会在任何表达式被解析和求值之前先行被解析和求值。即使声明位于源代码中的</p>
<p>最后一行，它也会先于同一作用域中位于最前面的表达式被求值。还是看个例子更容易理解。在下面这个例子中，函数 fn 是在 alert 后面声明的。但是，在 </p>
<p>alert 执行的时候，fn已经有定义了：</p>
<pre><code>alert(fn());

function fn() {
  return &apos;Hello world!&apos;;
}
</code></pre><p><strong>函数声明有一个重要的注意事项</strong>：就是千万不要在条件语句中使用函数声明，而要使用函数表达式。因为通过条件语句控制函数声明的行为并未标准化，</p>
<p>因此不同环境下可能会得到不同的结果。</p>
<pre><code>// 千万不要这样做！
// 有的浏览器会把foo声明为返回first的那个函数
// 而有的浏览器则会让foo返回second

if (true) {
  function foo() {
    return &apos;first&apos;;
  }
}
else {
  function foo() {
    return &apos;second&apos;;
  }
}
foo();

// 这种情况下要使用函数表达式：
var foo;
if (true) {
  foo = function() {
    return &apos;first&apos;;
  };
}
else {
  foo = function() {
    return &apos;second&apos;;
  };
}
foo();
</code></pre><p>函数声明的实际规则如下：</p>
<p>FunctionDeclaration（函数声明）只能出现在Program（程序）或FunctionBody（函数体）内。</p>
<p>从句法上讲，它们 不能出现在Block（块）（{ … }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块） 中只能包含Statement（语句）， 而不能包含FunctionDeclaration（函数声明）这样的SourceElement（源元素）。</p>
<p>另一方面，唯一可能让Expression（表达式）出现在Block（块）中情形，就是让它作为ExpressionStatement（表达式语句）的一部分。但是，规范明确规定了ExpressionStatement（表达式语句）不能以关键字function开头。而这实际上就是说，FunctionExpression（函数表达式）同样也不能出现在Statement（语句）或Block（块）中（别忘了Block（块）就是由Statement（语句）构成的）。</p>
<h2 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h2><p>函数表达式实际上还是很常见的。Web开发中有一个常用的模式，即基于对某种特性的测试来“伪装”函数定义，从而实现性能最优化。由于这种伪装通常都</p>
<p>出现在相同的作用域中，因此基本上一定要使用函数表达式。毕竟，如前所述，不应该根据条件来执行函数声明：</p>
<pre><code>var contains = (function() {
  var docEl = document.documentElement;

  if (typeof docEl.compareDocumentPosition != &apos;undefined&apos;) {
    return function(el, b) {
      return (el.compareDocumentPosition(b) &amp; 16) !== 0;
    }
  }
  else if (typeof docEl.contains != &apos;undefined&apos;) {
    return function(el, b) {
      return el !== b &amp;&amp; el.contains(b);
    }
  }
  return function(el, b) {
    if (el === b) return false;
    while (el != b &amp;&amp; (b = b.parentNode) != null);
    return el === b;
  }
})();
</code></pre><p>提到命名函数表达式，很显然，指的就是有名字（技术上称为标识符）的函数表达式。在最前面的例子中，var bar = function foo(){};实际上就是一个以foo</p>
<p>作为函数名字的函数表达式。对此，有一个细节特别重要，请大家一定要记住，即这个名字只在新定义的函数的作用域中有效——规范要求标识符不能在外</p>
<p>围的作用域中有效：</p>
<pre><code>var f = function foo(){
  return typeof foo; // foo只在内部作用域中有效
};
// foo在“外部”永远是不可见的
typeof foo; // &quot;undefined&quot;
f(); // &quot;function&quot;
</code></pre><p>有名字的函数可以让调试过程更加方便。在调试应用程序时，如果调用栈中的项都有各自描述性的名字，那么调试过程带给人的就是另一种完全不同的感</p>
<p>受。</p>
<h2 id="调试器中的函数名"><a href="#调试器中的函数名" class="headerlink" title="调试器中的函数名"></a>调试器中的函数名</h2><p>在函数有相应标识符的情况下，调试器会将该标识符作为函数的名字显示在调用栈中。有的调试器（例如Firebug）甚至会为匿名函数起个名字并显示出来，</p>
<p>让它们与那些引用函数的变量具有相同的角色。可遗憾的是，这些调试器通常只使用简单的解析规则，而依据简单的解析规则提取出来的“名字”有时候没有</p>
<p>多大价值，甚至会得到错误结果。</p>
<p>下面我们来看一个简单的例子：</p>
<pre><code>function foo(){
  return bar();
}
function bar(){
  return baz();
}
function baz(){
  debugger;
}
foo();

// 这里使用函数声明定义了3个函数
// 当调试器停止在debugger语句时，
// Firgbug的调用栈看起来非常清晰：
baz
bar
foo
expr_test.html()
</code></pre><p>我们可以清晰地知道foo调用了bar，而后者接着又调用了baz（而foo本身又在expr_test.html文档的全局作用域中被调用）。但真正值得称道的，则是</p>
<p>Firebug会在我们使用匿名表达式的情况下，替我们解析函数的“名字”：</p>
<pre><code>function foo(){
  return bar();
}
var bar = function(){
  return baz();
}
function baz(){
  debugger;
}
foo();

// 调用栈：
baz
bar()
foo
expr_test.html()
</code></pre><p>相反，不那么令人满意的情况是，当函数表达式复杂一些时（现实中差不多总是如此），调试器再如何尽力也不会起多大的作用。结果，我们只能在调用栈中</p>
<p>显示函数名字的位置上赫然看到一个问号：</p>
<pre><code>function foo(){
  return bar();
}
var bar = (function(){
  if (window.addEventListener) {
    return function(){
      return baz();
    }
  }
  else if (window.attachEvent) {
    return function() {
      return baz();
    }
  }
})();
function baz(){
  debugger;
}
foo();

// 调用栈：
baz
(?)()
foo
expr_test.html()
</code></pre><p>此外，当把一个函数赋值给多个变量时，还会出现一个令人困惑的问题：</p>
<pre><code>function foo(){
  return baz();
}
var bar = function(){
  debugger;
};
var baz = bar;
bar = function() { 
  alert(&apos;spoofed&apos;);
}
foo();

// 调用栈：
bar()
foo
expr_test.html()
</code></pre><p>可见，调用栈中显示的是foo调用了bar。但实际情况显然并非如此。之所以会造成这种困惑，完全是因为baz与另一个函数——包含代码alert(‘spoofed’);的函</p>
<p>数——“交换了”引用所致。实事求是地说，这种解析方式在简单的情况下固然好，但对于不那么简单的大多数情况而言就没有什么用处了。</p>
<p>归根结底，只有命名函数表达式才是产生可靠的栈调用信息的唯一途径。下面我们有意使用命名函数表达式来重写前面的例子。请大家注意，从自执行包装</p>
<p>块中返回的两个函数都被命名为了bar：</p>
<pre><code>function foo(){
  return bar();
}
var bar = (function(){
  if (window.addEventListener) {
    return function bar(){
      return baz();
    }
  }
  else if (window.attachEvent) {
    return function bar() {
      return baz();
    }
  }
})();
function baz(){
  debugger;
}
foo();

// 这样，我们就又可以看到清晰的调用栈信息了！
baz
bar
foo
expr_test.html()
</code></pre><p>OK，我们又学到了一招。</p>
<p>参考文章：<a href="http://www.jb51.net/onlineread/named-function-expressions-demystified/" target="_blank" rel="external">命名函数表达式探秘</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓命名函数表达式就是被赋予了名字的函数表达式，和它相对的是匿名函数，从简单的角度来看，命名函数表达式可以在调试器或性能分析程序中描述函&lt;/p&gt;
&lt;p&gt;数的名称，在调试过程中有着不小的作用，因为通常在跨浏览器开发中都会出现一些小毛病，命名函数表达式可以帮助我们解决它们。&lt;/p&gt;
&lt;p&gt;先来看一下函数表达式与函数声明以及现代调试器如何处理它们之类的内容。&lt;/p&gt;
&lt;h2 id=&quot;函数表达式与函数声明&quot;&gt;&lt;a href=&quot;#函数表达式与函数声明&quot; class=&quot;headerlink&quot; title=&quot;函数表达式与函数声明&quot;&gt;&lt;/a&gt;函数表达式与函数声明&lt;/h2&gt;&lt;p&gt;通常，我们可以通过函数表达式与函数声明来创建函数对象的方法。但是具体来说什么是函数表达式、什么是函数声明呢？在ECMA规范中明确了一点，函&lt;/p&gt;
&lt;p&gt;数声明必须始终带有标志符——即函数名，而函数表达式可以省略这个标识符，如：&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://fanwalker.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之原型和原型链</title>
    <link href="http://fanwalker.com/2017/08/25/JavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://fanwalker.com/2017/08/25/JavaScript之原型和原型链/</id>
    <published>2017-08-25T13:23:51.000Z</published>
    <updated>2017-11-18T08:20:55.725Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript不包含传统的类继承模型，使用的是prototypal模型即原型模型，虽然这经常被当作是 JavaScript 的缺点被提及，其实基于原型的继承模型比传统</p>
<p>的类继承还要强大。实现传统的类继承模型是很简单，但是实现 JavaScript 中的原型继承则要困难的多。</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>先来了解什么是原型（prototype）：javascript中的每个对象都有prototype属性，Javascript中对象的prototype属性的解释是：返回对象类型原型的引用。</p>
<p>如：<br><a id="more"></a></p>
<pre><code>A.prototype = new B();
</code></pre><p>理解prototype不应把它和继承混淆。A的prototype为B的一个实例，可以理解A将B中的方法和属性全部克隆了一遍。A能使用B的方法和属性。这里强调的是</p>
<p>克隆而不是继承。可以出现这种情况：A的prototype是B的实例，同时B的prototype也是A的实例。简单说了一下原型的概念，接下来看一下原型是怎么应用</p>
<p>的。一开始学JavaScript的时候，一般会如下面一样写代码：</p>
<pre><code>var decimalDigits = 2,
    tax = 5;

function add(x, y) {
    return x + y;
}

function subtract(x, y) {
    return x - y;
}

//alert(add(1, 3));
</code></pre><p>通过执行各个function来得到结果，学习了原型之后，我们可以使用如下方式来美化一下代码：</p>
<h3 id="原型使用方式1："><a href="#原型使用方式1：" class="headerlink" title="原型使用方式1："></a>原型使用方式1：</h3><p>在使用原型之前，我们需要先将代码做一下小修改：</p>
<pre><code>var Calculator = function (decimalDigits, tax) {
    this.decimalDigits = decimalDigits;
    this.tax = tax;
};
</code></pre><p>然后，通过给Calculator对象的prototype属性赋值对象字面量来设定Calculator对象的原型</p>
<pre><code>Calculator.prototype = {
    add: function (x, y) {
        return x + y;
    },

    subtract: function (x, y) {
        return x - y;
    }
};
//alert((new Calculator()).add(1, 3));
</code></pre><p>这样，我们就可以new Calculator对象以后，就可以调用add方法来计算结果了。</p>
<h3 id="原型使用方式2"><a href="#原型使用方式2" class="headerlink" title="原型使用方式2"></a>原型使用方式2</h3><p>第二种方式是，在赋值原型prototype的时候使用function立即执行的表达式来赋值，即如下格式：</p>
<pre><code>Calculator.prototype = function () { } ();
</code></pre><p>它可以封装私有的function，通过return的形式暴露出简单的使用名称，以达到public/private的效果，修改后的代码如下：</p>
<pre><code>Calculator.prototype = function () {
    add = function (x, y) {
        return x + y;
    },

    subtract = function (x, y) {
        return x - y;
    }
    return {
        add: add,
        subtract: subtract
    }
} ();

//alert((new Calculator()).add(11, 3));
</code></pre><p>同样的方式，我们可以new Calculator对象以后调用add方法来计算结果了。</p>
<h3 id="分步声明："><a href="#分步声明：" class="headerlink" title="分步声明："></a>分步声明：</h3><p>上述使用原型的时候，有一个限制就是一次性设置了原型对象，我们再来说一下如何分开设置原型的每个属性吧。</p>
<pre><code>var BaseCalculator = function () {
    //为每个实例都声明一个小数位数
    this.decimalDigits = 2;
};

//使用原型给BaseCalculator扩展2个对象方法
BaseCalculator.prototype.add = function (x, y) {
    return x + y;
};

BaseCalculator.prototype.subtract = function (x, y) {
    return x - y;
};
</code></pre><p>首先，声明了一个BaseCalculator对象，构造函数里会初始化一个小数位数的属性decimalDigits，然后通过原型属性设置2个function，分别是add(x,y)和</p>
<p>subtract(x,y)，当然你也可以使用前面提到的2种方式的任何一种，我们的主要目的是看如何将BaseCalculator对象设置到真正的Calculator的原型上。</p>
<p>创建完上述代码以后，我们来开始：</p>
<pre><code>var Calculator = function () {

    //为每个实例都声明一个税收数字
    this.tax = 5;
};

Calculator.prototype = new BaseCalculator();
</code></pre><p>我们可以看到Calculator的原型是指向到BaseCalculator的一个实例上，目的是让Calculator集成它的add(x,y)和subtract(x,y)这2个function，还有一点要说的</p>
<p>是，由于它的原型是BaseCalculator的一个实例，所以不管你创建多少个Calculator对象实例，他们的原型指向的都是同一个实例。</p>
<pre><code>var calc = new Calculator();
alert(calc.add(1, 1));

//BaseCalculator 里声明的decimalDigits属性，在 Calculator里是可以访问到的
alert(calc.decimalDigits); 
</code></pre><p>上面的代码，运行以后，我们可以看到因为Calculator的原型是指向BaseCalculator的实例上的，所以可以访问他的decimalDigits属性值，那如果我不想让</p>
<p>Calculator访问BaseCalculator的构造函数里声明的属性值，那怎么办呢？这么办：</p>
<pre><code>var Calculator = function () {
    this.tax= 5;
};

Calculator.prototype = BaseCalculator.prototype;
</code></pre><p>通过将BaseCalculator的原型赋给Calculator的原型，这样你在Calculator的实例上就访问不到那个decimalDigits值了，如果运行上面的代码 </p>
<p><code>alert(calc.decimalDigits)</code>，那将会提升出错。</p>
<h3 id="重写原型"><a href="#重写原型" class="headerlink" title="重写原型"></a>重写原型</h3><p>在使用第三方JS类库的时候，往往有时候他们定义的原型方法是不能满足我们的需要，但是又离不开这个类库，所以这时候我们就需要重写他们的原型中的</p>
<p>一个或者多个属性或function，我们可以通过向Calculator的原型上继续声明同样的add代码来达到覆盖重写前面的add功能，代码如下：</p>
<pre><code>//覆盖前面Calculator的add() function 
Calculator.prototype.add = function (x, y) {
    return x + y + this.tax;
};

var calc = new Calculator();
alert(calc.add(1, 1));
</code></pre><p>这样，我们计算得出的结果就比原来多出了一个tax的值，但是有一点需要注意：那就是重写的代码需要放在最后，这样才能覆盖前面的代码。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>在介绍原型链之前，我们先看一段代码：</p>
<pre><code>function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// 设置Bar的prototype属性为Foo的实例对象
Bar.prototype = new Foo();
Bar.prototype.foo = &apos;Hello World&apos;;

// 修正Bar.prototype.constructor为Bar本身
Bar.prototype.constructor = Bar;

var test = new Bar() // 创建Bar的一个新实例

// 原型链
test [Bar的实例]
    Bar.prototype [Foo的实例] 
        { foo: &apos;Hello World&apos; }
        Foo.prototype
            {method: ...};
            Object.prototype
                {toString: ... /* etc. */};
</code></pre><p>上面的例子中，test 对象从 Bar.prototype 和 Foo.prototype 继承下来；因此，它能访问 Foo 的原型方法 method。同时，它也能够访问那个定义在Bar原型</p>
<p>上的 Foo 实例属性 value。需要注意的是 new Bar() 不会创造出一个新的 Foo 实例，而是重复使用它原型上的那个实例；因此，所有的 Bar 实例都会共享相</p>
<p>同的 value 属性。</p>
<h3 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h3><p>当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部——也就是 Object.prototype ， 但是仍</p>
<p>然没有找到指定的属性，就会返回 undefined，我们来看一个例子：</p>
<pre><code>function foo() {
    this.add = function (x, y) {
        return x + y;
    }
}

foo.prototype.add = function (x, y) {
    return x + y + 10;
}

Object.prototype.subtract = function (x, y) {
    return x - y;
}

var f = new foo();
alert(f.add(1, 2)); //结果是3，而不是13
alert(f.subtract(1, 2)); //结果是-1
</code></pre><p>通过代码运行，我们发现subtract是安装我们所说的向上查找来得到结果的，但是add方式有点小不同，这也是我想强调的，就是属性在查找的时候是先查找</p>
<p>自身的属性，如果没有再查找原型，再没有，再往上走，一直插到Object的原型上，所以在某种层面上说，用 for in语句遍历属性的时候，效率也是个问题。</p>
<h3 id="hasOwnProperty函数："><a href="#hasOwnProperty函数：" class="headerlink" title="hasOwnProperty函数："></a>hasOwnProperty函数：</h3><p>hasOwnProperty是Object.prototype的一个方法，它能判断一个对象是否包含自定义属性而不是原型链上的属性，因为hasOwnProperty 是 JavaScript 中唯</p>
<p>一 一个处理属性但是不查找原型链的函数。</p>
<pre><code>// 修改Object.prototype
Object.prototype.bar = 1; 
var foo = {goo: undefined};

foo.bar; // 1
&apos;bar&apos; in foo; // true

foo.hasOwnProperty(&apos;bar&apos;); // false
foo.hasOwnProperty(&apos;goo&apos;); // true
</code></pre><p>只有 hasOwnProperty 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。 没有其它方法可以用来排除原型链上的属性，通过hasOwnProperty</p>
<p>可以找到定义在对象自身上的属性。但有个恶心的地方是：JavaScript 不会保护 hasOwnProperty 被非法占用，因此如果一个对象碰巧存在这个属</p>
<p>性，就需要使用外部的 hasOwnProperty 函数来获取正确的结果。</p>
<pre><code>var foo = {
    hasOwnProperty: function() {    //hasOwnProperty被非法占用
        return false;
    },
    bar: &apos;Here be dragons&apos;
};

foo.hasOwnProperty(&apos;bar&apos;); // 总是返回 false

// 使用{}对象的 hasOwnProperty，并将其上下为设置为foo
{}.hasOwnProperty.call(foo, &apos;bar&apos;); // true
</code></pre><p>当检查对象上某个属性是否存在时，hasOwnProperty 是唯一可用的方法。同时在使用 for in loop 遍历对象时，推荐总是使用 hasOwnProperty 方法，这将</p>
<p>会避免原型对象扩展带来的干扰，我们来看一下例子：</p>
<pre><code>// 修改 Object.prototype
Object.prototype.bar = 1;

var foo = {moo: 2};
for(var i in foo) {
    console.log(i); // 输出两个属性：bar 和 moo
}
</code></pre><p>我们没办法改变for in语句的行为，所以想过滤结果就只能使用hasOwnProperty 方法，代码如下：</p>
<pre><code>// foo 变量是上例中的
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}
</code></pre><p>这个版本的代码是唯一正确的写法。由于我们使用了 hasOwnProperty，所以这次只输出 moo。如果不使用hasOwnProperty，则这段代码在原生对象原型</p>
<p>（比如 Object.prototype）被扩展时可能会出错。</p>
<p><strong>总结：</strong>推荐使用 hasOwnProperty，不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。</p>
<h4 id="参考内容："><a href="#参考内容：" class="headerlink" title="参考内容："></a>参考内容：</h4><p><a href="http://bonsaiden.github.com/JavaScript-Garden/zh/" target="_blank" rel="external">http://bonsaiden.github.com/JavaScript-Garden/zh/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript不包含传统的类继承模型，使用的是prototypal模型即原型模型，虽然这经常被当作是 JavaScript 的缺点被提及，其实基于原型的继承模型比传统&lt;/p&gt;
&lt;p&gt;的类继承还要强大。实现传统的类继承模型是很简单，但是实现 JavaScript 中的原型继承则要困难的多。&lt;/p&gt;
&lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;原型&lt;/h2&gt;&lt;p&gt;先来了解什么是原型（prototype）：javascript中的每个对象都有prototype属性，Javascript中对象的prototype属性的解释是：返回对象类型原型的引用。&lt;/p&gt;
&lt;p&gt;如：&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://fanwalker.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的this</title>
    <link href="http://fanwalker.com/2017/08/22/JavaScript%E4%B8%AD%E7%9A%84this/"/>
    <id>http://fanwalker.com/2017/08/22/JavaScript中的this/</id>
    <published>2017-08-22T07:04:08.000Z</published>
    <updated>2017-11-18T08:21:08.388Z</updated>
    
    <content type="html"><![CDATA[<p>原文出自：<a href="https://segmentfault.com/a/1190000002640298#articleHeader3" target="_blank" rel="external">JavaScript中的this陷阱的最全收集–没有之一</a></p>
<p>个人觉得，如果需要掌握一门语言，掌握它的API只是学了皮毛，理解这门语言的精髓才是重点，提及JavaScript的精髓，<strong>this</strong>、<strong>闭包</strong>、<strong>作用域链</strong>、<strong>函数</strong>是当之无愧的。</p>
<p>JavaScript中很多时候会用到this，下面详细介绍每一种情况。在这里我想首先介绍一下宿主环境这个概念。一门语<br>言在运行的时候，需要一个环境，叫做宿主环境。对于JavaScript，宿主环境最常见的是web浏览器，浏览器提供了<a id="more"></a><br>一个JavaScript运行的环境，这个环境里面，需要提供一些接口，好让JavaScript引擎能够和宿主环境对接。<br>JavaScript引擎才是真正执行JavaScript代码的地方，常见的引擎有V8(目前最快JavaScript引擎、Google生<br>产)、JavaScript core。JavaScript引擎主要做了下面几件事情：</p>
<pre><code>一套与宿主环境相联系的规则;
JavaScript引擎内核（基本语法规范、逻辑、命令和算法);
一组内置对象和API;
其他约定
</code></pre><h3 id="global-this"><a href="#global-this" class="headerlink" title="global this"></a>global this</h3><p>在浏览器里，在全局范围内，this等价于window对象。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    console.log(this === window); //true
&lt;/script&gt;
</code></pre><p>在浏览器里，在全局范围内，用var声明一个变量和给this或者window添加属性是等价的</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var foo = &quot;bar&quot;;
    console.log(this.foo); //logs &quot;bar&quot;
    console.log(window.foo); //logs &quot;bar&quot;
&lt;/script&gt;
</code></pre><p>如果你在声明一个变量的时候没有使用var或者let(ECMAScript 6),你就是在给全局的this添加或者改变属性值。</p>
<pre><code> &lt;script type=&quot;text/javascript&quot;&gt;
     foo = &quot;bar&quot;;

     function testThis() {
       foo = &quot;foo&quot;;
     }

     console.log(this.foo); //logs &quot;bar&quot;
     testThis();
     console.log(this.foo); //logs &quot;foo&quot;
&lt;/script&gt;
</code></pre><p>在node环境里，如果使用REPL(Read-Eval-Print Loop，简称REPL:读取-求值-输出,是一个简单的，交互式的编程环境)来执行程序,this并不是最高级的命名空间，最高级的是global.</p>
<pre><code>&gt; this
{ ArrayBuffer: [Function: ArrayBuffer],
  Int8Array: { [Function: Int8Array] BYTES_PER_ELEMENT: 1 },
  Uint8Array: { [Function: Uint8Array] BYTES_PER_ELEMENT: 1 },
  ...
&gt; global === this
true
</code></pre><p><img src="http://i.imgur.com/7ej2SHo.png" alt=""><br><img src="http://i.imgur.com/OQNwaVx.png" alt=""></p>
<p>在node环境里，如果执行一个js脚本，在全局范围内，this以一个空对象开始作为最高级的命名空间，这个时候，它和global不是等价的。</p>
<pre><code>test.js脚本内容：

console.log(this);
console.log(this === global);

REPL运行脚本：

$ node test.js
{}
false
</code></pre><p>在node环境里，在全局范围内，如果你用REPL执行一个脚本文件，用var声明一个变量并不会和在浏览器里面一样将这个变量添加给this。</p>
<pre><code>test.js:

var foo = &quot;bar&quot;;
console.log(this.foo);

$ node test.js
undefined
</code></pre><p>但是如果你不是用REPL执行脚本文件，而是直接执行代码，结果和在浏览器里面是一样的(神坑)</p>
<pre><code>&gt; var foo = &quot;bar&quot;;
&gt; this.foo
bar
&gt; global.foo
bar
</code></pre><p>在node环境里，用REPL运行脚本文件的时候，如果在声明变量的时候没有使用var或者let，这个变量会自动添加到global对象，但是不会自动添加给this对象。如果是直接执行代码，则会同时添加给global和this</p>
<pre><code>test.js

foo = &quot;bar&quot;;
console.log(this.foo);
console.log(global.foo);

$ node test.js
undefined
bar
</code></pre><p>上面的八种情况总结起来就是：在浏览器里面this是老大，它等价于window对象，如果你声明一些全局变量(不管在任何地方)，这些变量都会作为this的属性。在node里面，有两种执行JavaScript代码的方式，一种是直接执行写好的JavaScript文件，另外一种是直接在里面执行一行行代码。对于直接运行一行行JavaScript代码的方式，global才是老大，this和它是等价的。在这种情况下，和浏览器比较相似，也就是声明一些全局变量会自动添加给老大global，顺带也会添加给this。但是在node里面直接脚本文件就不一样了，你声明的全局变量不会自动添加到this，但是会添加到global对象。所以相同点是，在全局范围内，全局变量终究是属于老大的。</p>
<h3 id="function-this"><a href="#function-this" class="headerlink" title="function this"></a>function this</h3><p>无论是在浏览器环境还是node环境， 除了在DOM事件处理程序里或者给出了thisArg(接下来会讲到)外，如果不是用new调用，在函数里面使用this都是指代全局范围的this。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
  foo = &quot;bar&quot;;
  function testThis() {
    this.foo = &quot;foo&quot;;
  }
  console.log(this.foo); //logs &quot;bar&quot;
  testThis();
  console.log(this.foo); //logs &quot;foo&quot;
&lt;/script&gt;
</code></pre><!-- -->
<pre><code>test.js

foo = &quot;bar&quot;;
function testThis () {
  this.foo = &quot;foo&quot;;
}
console.log(global.foo);
testThis();
console.log(global.foo);

$ node test.js
bar
foo
</code></pre><p>除非你使用严格模式，这时候this就会变成undefined。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
     foo = &quot;bar&quot;;

     function testThis() {
       &quot;use strict&quot;;
       this.foo = &quot;foo&quot;;
     }

     console.log(this.foo); //logs &quot;bar&quot;
     testThis();  //Uncaught TypeError: Cannot set property &apos;foo&apos; of undefined 
 &lt;/script&gt;
</code></pre><p>如果你在调用函数的时候在前面使用了new，this就会变成一个新的值，和global的this脱离干系。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    foo = &quot;bar&quot;;

    function testThis() {
      this.foo = &quot;foo&quot;;
    }

    console.log(this.foo); //logs &quot;bar&quot;
    new testThis();
    console.log(this.foo); //logs &quot;bar&quot;

    console.log(new testThis().foo); //logs &quot;foo&quot;
&lt;/script&gt;
</code></pre><p>我更喜欢把新的值称作一个实例。</p>
<blockquote>
<p>函数里面的this其实相对比较好理解，如果我们在一个函数里面使用this，需要注意的就是我们调用函数的方式，如果是正常的方式调用函数，this指代全局的this，如果我们加一个new，这个函数就变成了一个构造函数，我们就创建了一个实例，this指代这个实例，这个和其他面向对象的语言很像。另外，写JavaScript很常做的一件事就是绑定事件处理程序，也就是诸如button.addEventListener(‘click’, fn, false)之类的，如果在fn里面需要使用this，this指代事件处理程序对应的对象，也就是button。</p>
</blockquote>
<h3 id="prototype-this"><a href="#prototype-this" class="headerlink" title="prototype this"></a>prototype this</h3><p>你创建的每一个函数都是函数对象。它们会自动获得一个特殊的属性prototype，你可以给这个属性赋值。当你用new的方式调用一个函数的时候，你就能通过this访问你给prototype赋的值了。</p>
<pre><code>function Thing() {
      console.log(this.foo);
}

Thing.prototype.foo = &quot;bar&quot;;

var thing = new Thing(); //logs &quot;bar&quot;
console.log(thing.foo);  //logs &quot;bar&quot;
</code></pre><p>当你使用new为你的函数创建多个实例的时候，这些实例会共享给你prototype设定的值。对于下面的例子，当你调用this.foo的时候，都会返回相同的值，除非你在某个实例里面重写了自己的this.foo</p>
<pre><code>function Thing() {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () {
    console.log(this.foo);
}
Thing.prototype.setFoo = function (newFoo) {
    this.foo = newFoo;
}

var thing1 = new Thing();
var thing2 = new Thing();

thing1.logFoo(); //logs &quot;bar&quot;
thing2.logFoo(); //logs &quot;bar&quot;

thing1.setFoo(&quot;foo&quot;);
thing1.logFoo(); //logs &quot;foo&quot;;
thing2.logFoo(); //logs &quot;bar&quot;;

thing2.foo = &quot;foobar&quot;;
thing1.logFoo(); //logs &quot;foo&quot;;
thing2.logFoo(); //logs &quot;foobar&quot;;
</code></pre><p>实例里面的this是一个特殊的对象。你可以把this想成一种获取prototype的值的一种方式。当你在一个实例里面直接给this添加属性的时候，会隐藏prototype中与之同名的属性。如果你想访问prototype中的这个属性值而不是你自己设定的属性值，你可以通过在实例里面删除你自己添加的属性的方式来实现。</p>
<pre><code>function Thing() {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () {
    console.log(this.foo);
}
Thing.prototype.setFoo = function (newFoo) {
    this.foo = newFoo;
}
Thing.prototype.deleteFoo = function () {
    delete this.foo;
}
var thing = new Thing();
thing.setFoo(&quot;foo&quot;);
thing.logFoo(); //logs &quot;foo&quot;;
thing.deleteFoo();
thing.logFoo(); //logs &quot;bar&quot;;
thing.foo = &quot;foobar&quot;;
thing.logFoo(); //logs &quot;foobar&quot;;
delete thing.foo;
thing.logFoo(); //logs &quot;bar&quot;;
</code></pre><p>或者你也能直接通过引用函数对象的prototype 来获得你需要的值。</p>
<pre><code>function Thing() {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () {
    console.log(this.foo, Thing.prototype.foo);
}

var thing = new Thing();
thing.foo = &quot;foo&quot;;
thing.logFoo(); //logs &quot;foo bar&quot;;
</code></pre><p>通过一个函数创建的实例会共享这个函数的prototype属性的值，如果你给这个函数的prototype赋值一个Array，那么所有的实例都会共享这个Array，除非你在实例里面重写了这个Array，这种情况下，函数的prototype的Array就会被隐藏掉。</p>
<pre><code>function Thing() {
}
Thing.prototype.things = []; 

var thing1 = new Thing();
var thing2 = new Thing();
thing1.things.push(&quot;foo&quot;);
console.log(thing2.things); //logs [&quot;foo&quot;]
</code></pre><p>从上面可以看出给一个函数的prototype赋值一个Array通常是一个错误的做法。每一个实例都共享一个Array，没有自己专属的Array，如果你想每一个实例有他们专属的Array，你应该在函数里面创建而不是在prototype里面创建。</p>
<pre><code>function Thing() {
    this.things = [];
}


var thing1 = new Thing();
var thing2 = new Thing();
thing1.things.push(&quot;foo&quot;);
console.log(thing1.things); //logs [&quot;foo&quot;]
console.log(thing2.things); //logs []
</code></pre><p>实际上你可以通过把多个函数的prototype链接起来的从而形成一个原型链，因此this就会魔法般地沿着这条原型链往上查找直到找你你需要引用的值。</p>
<pre><code>function Thing1() {
}
Thing1.prototype.foo = &quot;bar&quot;;

function Thing2() {
}
Thing2.prototype = new Thing1();


var thing = new Thing2();
console.log(thing.foo); //logs &quot;bar&quot;
</code></pre><p>一些人利用原型链的特性来在JavaScript模仿经典的面向对象的继承方式。任何给用于构建原型链的函数的this的赋值的语句都会隐藏原型链上游的相同的属性。</p>
<pre><code>function Thing1() {
}
Thing1.prototype.foo = &quot;bar&quot;;

function Thing2() {
    this.foo = &quot;foo&quot;;  //与原型链上游属性相同，覆盖上游属性
}
Thing2.prototype = new Thing1();

function Thing3() {
}
Thing3.prototype = new Thing2();

var thing = new Thing3();
 console.log(thing.foo); //logs &quot;foo&quot;
</code></pre><p>我喜欢把被赋值给prototype的函数叫做方法。在上面的例子中，我已经使用过方法了，如logFoo。这些方法有着相同的prototype，即创建这些实例的原始函数。我通常把这些原始函数叫做构造函数。在定义的方法里面使用this会影响到当前实例的原型链的上游的this。这意味着你直接给this赋值的时候，隐藏了原型链上游的相同的属性值。这个实例的任何方法都会使用这个最新的值而不是原型里面定义的这个相同的值。</p>
<pre><code>function Thing1() {
}
Thing1.prototype.foo = &quot;bar&quot;;
Thing1.prototype.logFoo = function () {
    console.log(this.foo);
}

function Thing2() {
    this.foo = &quot;foo&quot;;
}
Thing2.prototype = new Thing1();


var thing = new Thing2();
thing.logFoo(); //logs &quot;foo&quot;;
</code></pre><p>在JavaScript里面你可以嵌套函数，也就是你可以在函数里面定义函数。嵌套函数可以通过闭包捕获父函数的变量，但是这个函数没有继承this</p>
<pre><code>function Thing() {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () {
    var info = &quot;attempting to log this.foo:&quot;;
    function doIt() {
        console.log(info, this.foo); //此时在node环境中this是global对象，浏览器中是window对象
    }
    doIt();
}
var thing = new Thing();
thing.logFoo();  //logs &quot;attempting to log this.foo: undefined&quot;
</code></pre><p>在doIt里面的this是global对象或者在严格模式下面是undefined。这是造成很多不熟悉JavaScript的人深陷 this陷阱的根源。在这种情况下事情变得非常糟糕，就像你把一个实例的方法当作函数参数传递给另外一个函数但是却不把这个实例传递给这个函数一样。在这种情况下，一个方法里面的环境变成了全局范围，或者在严格模式下面的undefined。</p>
<pre><code>function Thing() {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () {  
    console.log(this.foo);   
}

function doIt(method) {
    method();
}


var thing = new Thing();
thing.logFoo(); //logs &quot;bar&quot;
doIt(thing.logFoo); //logs undefined
</code></pre><p>一些人喜欢先把this捕获到一个变量里面，通常这个变量叫做self，来避免上面这种情况的发生。</p>
<pre><code>function Thing() {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () {
    var self = this;
    var info = &quot;attempting to log this.foo:&quot;;
    function doIt() {
        console.log(info, self.foo);
    }
    doIt();
}


var thing = new Thing();
thing.logFoo();  //logs &quot;attempting to log this.foo: bar&quot;
</code></pre><p>但是当你需要把一个方法作为一个值传递给一个函数的时候并不管用。</p>
<pre><code>function Thing() {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () { 
    var self = this;
    function doIt() {
        console.log(self.foo);
    }
    doIt();
}

function doItIndirectly(method) {
    method();
}


var thing = new Thing();
thing.logFoo(); //logs &quot;bar&quot;
doItIndirectly(thing.logFoo); //logs undefined
</code></pre><p>你可以通过bind将实例和方法一切传递给函数来解决这个问题，bind是一个函数，可以定义在所有函数和方法的函数对象上面</p>
<pre><code>function Thing() {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () { 
    console.log(this.foo);
}

function doIt(method) {
    method();
}


var thing = new Thing();
doIt(thing.logFoo.bind(thing)); //logs bar
</code></pre><p>你同样可以使用apply和call来在新的上下文中调用方法或函数。</p>
<pre><code>function Thing() {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () { 
    function doIt() {
        console.log(this.foo);
    }
    doIt.apply(this);
}

function doItIndirectly(method) {
    method();
}


var thing = new Thing();
doItIndirectly(thing.logFoo.bind(thing)); //logs bar
</code></pre><p>你可以用bind来代替任何一个函数或者方法的this，即便它没有赋值给实例的初始prototype。</p>
<pre><code>function Thing() {
}
Thing.prototype.foo = &quot;bar&quot;;


function logFoo(aStr) {
    console.log(aStr, this.foo);
}


var thing = new Thing();
logFoo.bind(thing)(&quot;using bind&quot;); //logs &quot;using bind bar&quot;
logFoo.apply(thing, [&quot;using apply&quot;]); //logs &quot;using apply bar&quot;
logFoo.call(thing, &quot;using call&quot;); //logs &quot;using call bar&quot;
logFoo(&quot;using nothing&quot;); //logs &quot;using nothing undefined&quot;
</code></pre><p>你应该避免在构造函数里面返回任何东西，因为这可能代替本来应该返回的实例。</p>
<pre><code>function Thing() {
    return {};
}
Thing.prototype.foo = &quot;bar&quot;;


Thing.prototype.logFoo = function () {
    console.log(this.foo);
}


var thing = new Thing();
thing.logFoo(); //Uncaught TypeError: undefined is not a function
</code></pre><p>奇怪的是，如果你在构造函数里面返回了一个原始值，上面所述的情况并不会发生并且返回语句被忽略了。最好不要在你将通过new调用的构造函数里面返回任何类型的数据，即便你知道自己正在做什么。如果你想创建一个工厂模式，通过一个函数来创建一个实例，这个时候不要使用new来调用函数。当然这个建议是可选的</p>
<blockquote>
<p>你可以通过使用Object.create来避免使用new，这样同样能够创建一个实例。</p>
</blockquote>
<pre><code>function Thing() {
}
Thing.prototype.foo = &quot;bar&quot;;


Thing.prototype.logFoo = function () {
    console.log(this.foo);
}

var thing =  Object.create(Thing.prototype);
thing.logFoo(); //logs &quot;bar&quot;
</code></pre><p>在这种情况下并不会调用构造函数</p>
<pre><code>function Thing() {
    this.foo = &quot;foo&quot;;
}
Thing.prototype.foo = &quot;bar&quot;;


Thing.prototype.logFoo = function () {
    console.log(this.foo);
}


var thing =  Object.create(Thing.prototype);
thing.logFoo(); //logs &quot;bar&quot;
</code></pre><p>因为Object.create不会调用构造函数的特性在你继承模式下你想通过原型链重写构造函数的时候非常有用。</p>
<pre><code>function Thing1() {
    this.foo = &quot;foo&quot;;
}
Thing1.prototype.foo = &quot;bar&quot;;

function Thing2() {
    this.logFoo(); //logs &quot;bar&quot;
    Thing1.apply(this);
    this.logFoo(); //logs &quot;foo&quot;
}
Thing2.prototype = Object.create(Thing1.prototype);
Thing2.prototype.logFoo = function () {
    console.log(this.foo);
}

var thing = new Thing2();
</code></pre><h3 id="object-this"><a href="#object-this" class="headerlink" title="object this"></a>object this</h3><p>在一个对象的一个函数里，你可以通过this来引用这个对象的其他属性。这个用new来新建一个实例是不一样的。</p>
<pre><code>var obj = {
    foo: &quot;bar&quot;,
    logFoo: function () {
        console.log(this.foo);
    }
};

obj.logFoo(); //logs &quot;bar&quot;
</code></pre><p>注意，没有使用new，没有使用Object.create，也没有使用函数调用创建一个对象。你也可以将对象当作一个实例将函数绑定到上面。</p>
<pre><code>var obj = {
    foo: &quot;bar&quot;
};

function logFoo() {
    console.log(this.foo);
}

logFoo.apply(obj); //logs &quot;bar&quot;
</code></pre><p>当你用这种方式使用this的时候，并不会越出当前的对象。只有有相同直接父元素的属性才能通过this共享变量</p>
<pre><code>var obj = {
    foo: &quot;bar&quot;,
    deeper: {
        logFoo: function () {
            console.log(this.foo);
        }
    }
};

obj.deeper.logFoo(); //logs undefined
</code></pre><p>你可以直接通过对象引用你需要的属性</p>
<pre><code>var obj = {
    foo: &quot;bar&quot;,
    deeper: {
        logFoo: function () {
            console.log(obj.foo);
        }
    }
};

obj.deeper.logFoo(); //logs &quot;bar&quot;
</code></pre><h3 id="DOM-event-this"><a href="#DOM-event-this" class="headerlink" title="DOM event this"></a>DOM event this</h3><p>在一个HTML DOM事件处理程序里面，this始终指向这个处理程序被所绑定到的HTML DOM节点</p>
<pre><code>function Listener() {
    document.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;,
       this.handleClick);
}
Listener.prototype.handleClick = function (event) {
    console.log(this); //logs &quot;&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;&quot;
}

var listener = new Listener();
document.getElementById(&quot;foo&quot;).click();
</code></pre><p>除非你自己通过bind切换了上下文</p>
<pre><code>function Listener() {
    document.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;, 
        this.handleClick.bind(this));
}
Listener.prototype.handleClick = function (event) {
    console.log(this); //logs Listener {handleClick: function}
}

var listener = new Listener();
document.getElementById(&quot;foo&quot;).click();
</code></pre><h3 id="HTML-this"><a href="#HTML-this" class="headerlink" title="HTML this"></a>HTML this</h3><p>在HTML节点的属性里面，你可以放置JavaScript代码，this指向了这个元素</p>
<pre><code>&lt;div id=&quot;foo&quot; onclick=&quot;console.log(this);&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
document.getElementById(&quot;foo&quot;).click(); //logs &lt;div id=&quot;foo&quot;...
&lt;/script&gt;
</code></pre><h3 id="override-this"><a href="#override-this" class="headerlink" title="override this"></a>override this</h3><p>你不能重写this，因为它是保留字</p>
<pre><code>function test () {
    var this = {};  // Uncaught SyntaxError: Unexpected token this 
}
eval this
</code></pre><p>你可以通过eval来访问this</p>
<pre><code>function Thing () {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () {
    eval(&quot;console.log(this.foo)&quot;); //logs &quot;bar&quot;
}

var thing = new Thing();
thing.logFoo();
</code></pre><p>这会造成一个安全问题，除非不用eval，没有其他方式来避免这个问题。</p>
<p>在通过Function来创建一个函数的时候，同样能够访问this</p>
<pre><code>function Thing () {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = new Function(&quot;console.log(this.foo);&quot;);

var thing = new Thing();
thing.logFoo(); //logs &quot;bar&quot;
</code></pre><h3 id="with-this"><a href="#with-this" class="headerlink" title="with this"></a>with this</h3><p>你可以通过with来将this添加到当前的执行环境，并且读写this的属性的时候不需要通过this</p>
<pre><code>function Thing () {
}
Thing.prototype.foo = &quot;bar&quot;;
Thing.prototype.logFoo = function () {
    with (this) {
        console.log(foo);
        foo = &quot;foo&quot;;
    }
}

var thing = new Thing();
thing.logFoo(); // logs &quot;bar&quot;
console.log(thing.foo); // logs &quot;foo&quot;
</code></pre><p>许多人认为这样使用是不好的因为with本身就饱受争议。</p>
<h3 id="jQuery-this"><a href="#jQuery-this" class="headerlink" title="jQuery this"></a>jQuery this</h3><p>和HTML DOM元素节点的事件处理程序一样，在许多情况下JQuery的this都指向HTML元素节点。这在事件处理程序和一些方便的方法中都是管用的，比如$.each</p>
<pre><code>&lt;div class=&quot;foo bar1&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;foo bar2&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
$(&quot;.foo&quot;).each(function () {
    console.log(this); //logs &lt;div class=&quot;foo...
});
$(&quot;.foo&quot;).on(&quot;click&quot;, function () {
    console.log(this); //logs &lt;div class=&quot;foo...
});
$(&quot;.foo&quot;).each(function () {
    this.click();
});
&lt;/script&gt;
</code></pre><h3 id="thisArg-this"><a href="#thisArg-this" class="headerlink" title="thisArg this"></a>thisArg this</h3><p>如果你用过underscore.js 或者 lo-dash 你可能知道许多类库的方法可以通过一个叫做thisArg 的函数参数来传递实例，这个函数参数会作为this的上下文。举个例子，这适用于_.each。原生的JavaScript在ECMAScript 5的时候也允许函数传递一个thisArg参数了，比如forEach。事实上，之前阐述的bind，apply和call的使用已经给你创造了传递thisArg参数给函数的机会。这个参数将this绑定为你所传递的对象。</p>
<pre><code>function Thing(type) {
    this.type = type;
}
Thing.prototype.log = function (thing) {
    console.log(this.type, thing);
}
Thing.prototype.logThings = function (arr) {
   arr.forEach(this.log, this); // logs &quot;fruit apples...&quot;
}

var thing = new Thing(&quot;fruit&quot;);
thing.logThings([&quot;apples&quot;, &quot;oranges&quot;, &quot;strawberries&quot;, &quot;bananas&quot;]);
</code></pre><p>这使得代码变得更加简洁，因为避免了一大堆bind语句、函数嵌套和this暂存的使用。</p>
<h3 id="把上面的代码运行下效果更佳。"><a href="#把上面的代码运行下效果更佳。" class="headerlink" title="把上面的代码运行下效果更佳。"></a>把上面的代码运行下效果更佳。</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文出自：&lt;a href=&quot;https://segmentfault.com/a/1190000002640298#articleHeader3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript中的this陷阱的最全收集–没有之一&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;个人觉得，如果需要掌握一门语言，掌握它的API只是学了皮毛，理解这门语言的精髓才是重点，提及JavaScript的精髓，&lt;strong&gt;this&lt;/strong&gt;、&lt;strong&gt;闭包&lt;/strong&gt;、&lt;strong&gt;作用域链&lt;/strong&gt;、&lt;strong&gt;函数&lt;/strong&gt;是当之无愧的。&lt;/p&gt;
&lt;p&gt;JavaScript中很多时候会用到this，下面详细介绍每一种情况。在这里我想首先介绍一下宿主环境这个概念。一门语&lt;br&gt;言在运行的时候，需要一个环境，叫做宿主环境。对于JavaScript，宿主环境最常见的是web浏览器，浏览器提供了
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://fanwalker.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>websocket实现简单聊天程序</title>
    <link href="http://fanwalker.com/2017/08/20/websocket%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F/"/>
    <id>http://fanwalker.com/2017/08/20/websocket实现简单聊天程序/</id>
    <published>2017-08-20T09:06:17.000Z</published>
    <updated>2017-11-18T08:21:16.174Z</updated>
    
    <content type="html"><![CDATA[<p>程序的流程图：<br><a id="more"></a></p>
<p><img src="http://i.imgur.com/xNJdw2f.png" alt=""></p>
<h2 id="主要代码："><a href="#主要代码：" class="headerlink" title="主要代码："></a><strong>主要代码：</strong></h2><h3 id="服务端-app-js"><a href="#服务端-app-js" class="headerlink" title="服务端 app.js"></a>服务端 app.js</h3><p>先加载所需要的通信模块：</p>
<pre><code>var express = require(&apos;express&apos;);
var app = express();
var http = require(&apos;http&apos;).createServer(app);
var io = require(&apos;socket.io&apos;).listen(http);
var fs = require(&apos;fs&apos;);
</code></pre><p>创建用户列表和消息列表：</p>
<pre><code>var person = [];
var history = [];
</code></pre><p>绑定并监听80端口：</p>
<pre><code>app.get(&apos;/&apos;,function (req,res) {
    res.sendFile(__dirname + &apos;/login.html&apos;);
});

http.listen(80,function () {
    console.log(&apos;listening on *:80&apos;);
});
</code></pre><p>客户端连接成功后，触发响应事件connection，完成要绑定的事件并实现客户端出发的事件：</p>
<pre><code>io.sockets.on(&apos;connection&apos;,function (socket) {
    var user = &apos;&apos;;

    socket.emit(&apos;history&apos;, history);
    io.sockets.emit(&apos;updatePerson&apos;, person); 

    socket.on(&apos;sendMsg&apos;, function (data) {
        var obj = {};
        obj.content = data;
        obj.time = now();
        obj.name = user;
        if (history.length === history_num) {
            history.shift();
        }
        history.push(obj);
        io.sockets.emit(&apos;news&apos;, obj);
    });

    socket.on(&apos;setUserName&apos;, function (data) {
        user = data;
        person.push(user);
        io.sockets.emit(&apos;loginsucess&apos;);
        io.sockets.emit(&apos;updatePerson&apos;, person);
        io.sockets.emit(&apos;news&apos;, {content: user + &apos;进入房间&apos;, time: now(), name: &apos;系统消息&apos;});
    });

    socket.on(&apos;disconnect&apos;, function () {
        if (user !== &apos;&apos;) {
            person.forEach(function (value, index) {
                if (value === user) {
                    person.splice(index, 1);
                }
            });
            io.sockets.emit(&apos;news&apos;, {content: user + &apos;离开房间&apos;, time: now(), name: &apos;系统消息&apos;});
            io.sockets.emit(&apos;updatePerson&apos;, person);
        }
    });
});
</code></pre><h3 id="客户端-index-js："><a href="#客户端-index-js：" class="headerlink" title="客户端 index.js："></a>客户端 index.js：</h3><p>先初始化用户信息：</p>
<pre><code>$scope.data = [];     //消息队列  
$scope.name = &apos;&apos;;    //用户名
$scope.content = &apos;&apos;;  //用户输入的消息
$scope.personlist = []; //用户队列
</code></pre><p>然后连接服务器端：</p>
<pre><code>const  socket_url = &apos;http://localhost&apos;;
var socket = io.connect(socket_url);
</code></pre><p>连接成功后，对用户昵称输入的验证：</p>
<pre><code>$scope.checkName = function () {
    if($scope.name!==&apos;&apos;){
        if($scope.personlist.length!==0){
            if($scope.personlist.indexOf($scope.name)&gt;-1) {
                document.getElementById(&quot;info&quot;).textContent = &quot;该昵称已被占用，请重新输入&quot;;
            }
            else{
                socket.emit(&apos;setUserName&apos;, $scope.name);
            }
        }
        else{
            socket.emit(&apos;setUserName&apos;, $scope.name);
        }
    }
    else{
        document.getElementById(&apos;name&apos;).focus();
    }
};
</code></pre><p>验证成功后，对用户输入消息要触发的事件：</p>
<pre><code>$scope.sendMsg = function(data){
    var date = new Date();
    data = $scope.content;
    if($scope.content !== &apos;&apos;){
        socket.emit(&apos;sendMsg&apos;,data);
    }
    $scope.content = &apos;&apos;;
};
</code></pre><h4 id="程序的部分运行测试结果："><a href="#程序的部分运行测试结果：" class="headerlink" title="程序的部分运行测试结果："></a>程序的部分运行测试结果：</h4><p>浏览器输入localhost后展示的用户登录界面:</p>
<p><img src="http://i.imgur.com/puk3YKy.png" alt=""></p>
<p>昵称重复后的提示：</p>
<p><img src="http://i.imgur.com/nwZmF3S.png" alt=""></p>
<p>昵称输入成功后进入当前用户的聊天界面：</p>
<p><img src="http://i.imgur.com/92hHDKg.png" alt=""></p>
<p>源码地址：<a href="https://github.com/FanWalker/webchat" target="_blank" rel="external">GitHub</a></p>
<p>参考学习：</p>
<p>Node.js + Web Socket 打造即时聊天程序嗨聊：<a href="http://www.cnblogs.com/Wayou/p/hichat_built_with_nodejs_socket.html" target="_blank" rel="external">http://www.cnblogs.com/Wayou/p/hichat_built_with_nodejs_socket.html</a></p>
<p>基于websocket的一个简单的聊天室：<a href="https://github.com/ShanaMaid/websocket-express-webchat" target="_blank" rel="external">https://github.com/ShanaMaid/websocket-express-webchat</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序的流程图：&lt;br&gt;
    
    </summary>
    
    
      <category term="websocket" scheme="http://fanwalker.com/tags/websocket/"/>
    
      <category term="node.js" scheme="http://fanwalker.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 3D transform变换</title>
    <link href="http://fanwalker.com/2017/08/15/CSS3-3D-transform%E5%8F%98%E6%8D%A2/"/>
    <id>http://fanwalker.com/2017/08/15/CSS3-3D-transform变换/</id>
    <published>2017-08-15T05:34:29.000Z</published>
    <updated>2017-11-18T08:19:55.424Z</updated>
    
    <content type="html"><![CDATA[<p> 在学习慕课网H5+JS+CSS3实现圣诞情缘的时候遇到css3的3D转换，虽然也学习过css3的3d变化教程，但都是基于理论上，没有自己亲自应用过，所以现在使用的时候就有点吃力。今天就重新学习了一遍css3的3D变换。</p>
<h3 id="一、rotateX-rotateY-rotateZ"><a href="#一、rotateX-rotateY-rotateZ" class="headerlink" title="一、rotateX, rotateY, rotateZ"></a>一、rotateX, rotateY, rotateZ</h3><p>先介绍rotateX(), rotateY(), rotateZ()这三个方法，在介绍这三个方法之前我们先来一张图：</p>
<a id="more"></a>
<p><img src="http://i.imgur.com/mhm6zD7.png" alt=""></p>
<p>这是3d转换的基本图例，标志出了实物中x、y、z轴的分布，如果实在看不懂的画，可以找来一张纸，在纸上面横竖各放一只笔，横着的代表x轴，竖着代表y轴，最后立着放一只，代表z轴，这样就比较形象了。</p>
<p>现在就来看看rotateX(), rotateY(), rotateZ()这三个方法:<br>rotateX():图像绕着X轴旋转；rotateY()：图像绕着Y轴旋转；rotateZ()：图像绕着Z轴旋转；实际的效果图如下:</p>
<p><img src="http://i.imgur.com/DxLH8yA.gif" alt=""></p>
<h3 id="二、perspective属性"><a href="#二、perspective属性" class="headerlink" title="二、perspective属性"></a>二、perspective属性</h3><p>perspective直译成中文就是透视，也可以理解为视角，它的透视方式为近大远小，举个例子，在生活中，我们站在很远的地方看物体，这时的物体近似为一个点，但我们走近一点看的时候，物体棱角分明很立体长宽高都看的清清楚楚。</p>
<p>perspective属性设置镜头到元素平面的距离，这个镜头可以认为就是我们的眼睛，css3的3D transform的视点是在浏览器的前方，近似为我们眼睛所在的地方。举个例子，一个1680像素宽的显示器中有张美女图片，perspective值为2000像素，浏览器展示出来的效果就和你看距离你2000像素那么远的美女的效果是一样的。</p>
<p>设置perspective属性有两种方法，一种是用在动画元素的父辈元素上即舞台元素，如：</p>
<pre>
.stage{
   perspective:300px;
}
</pre>

<p>另一种就是写在当前的动画元素上,与transform的其他属性写在一起：</p>
<pre>
.curAnim{
   transform: perspective(300px) rotateX(90deg);
}
</pre>

<p>他们在展示一个元素的时候效果是一样的，但舞台上元素多起来的时候，效果就不一样了，更详细的demo展示，参考张鑫旭的博文<a href="http://www.zhangxinxu.com/wordpress/2012/09/css3-3d-transform-perspective-animate-transition/" target="_blank" rel="external">好吧，CSS3 3D transform变换，不过如此！</a></p>
<h3 id="三、translateZ属性"><a href="#三、translateZ属性" class="headerlink" title="三、translateZ属性"></a>三、translateZ属性</h3><p>translateZ属性是展示了近大远小的原理，translateZ的值越大，可以理解为元素距离我们的眼睛越近，看到的元素也越大，translateZ的值越小，元素距离我们就越远，看到的也就越小，如设置</p>
<pre>
perspective:300px;
</pre>

<p>当translateZ=300px时，元素会撑满整个页面，translateZ=-300px时，我们看到的元素就很小。</p>
<h3 id="四、perspective-origin属性"><a href="#四、perspective-origin属性" class="headerlink" title="四、perspective-origin属性"></a>四、perspective-origin属性</h3><p>perspective-origin属性设置的是你观看的位置，引用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/perspective-origin" target="_blank" rel="external">Mozilla 开发者网络（MDN）的描述</a>：</p>
<blockquote>
<p>The perspective-origin CSS property determines the position at which the viewer is looking. </p>
</blockquote>
<p>其默认值为perspective-origin:50% 50%;</p>
<p>可以通过实例来感受一下：<a href="https://www.w3cschool.cn/tryrun/showhtml/trycss3_perspective-origin1" target="_blank" rel="external">https://www.w3cschool.cn/tryrun/showhtml/trycss3_perspective-origin1</a></p>
<h3 id="五、transform-style-preserve-3d"><a href="#五、transform-style-preserve-3d" class="headerlink" title="五、transform-style: preserve-3d"></a>五、transform-style: preserve-3d</h3><p>transform-style属性是决定其子元素上用3d效果展示还是以2d平面效果展示，下面是来自<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-style" target="_blank" rel="external">Mozilla 开发者网络（MDN）的描述</a>：</p>
<blockquote>
<p>The transform-style CSS property determines if the children of the element are positioned in the 3D-space or are flattened in the plane of the element.</p>
</blockquote>
<p>perspective-style有两个参数flat|preserve-3d，flat是设置为平面展示没有3d效果，而preserve-3d则是以3d效果展示；</p>
<p>perspective-style一般是声明在3D变换的兄弟元素们的父元素上，也就是舞台元素。</p>
<h3 id="六、backface-visibility"><a href="#六、backface-visibility" class="headerlink" title="六、backface-visibility"></a>六、backface-visibility</h3><p>backface-visibility属性设置的是我们能否看到元素的背面，可设置的值有两个：visible | hidden：</p>
<p>backface-visibility : visible 效果图：</p>
<p><img src="http://i.imgur.com/JZylKXh.png" alt=""></p>
<p>backface-visibility : hidden 效果图：</p>
<p><img src="http://i.imgur.com/knyXZYV.png" alt=""></p>
<h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>这些属性虽然理解起来并不是很难，但如果没有用到实际中去也会很快的遗忘，重在实践。</p>
<p>给自己定个小目标，每天进步一点点！</p>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p>张鑫旭的博文：<a href="http://www.zhangxinxu.com/wordpress/?p=2592" target="_blank" rel="external">好吧，CSS3 3D transform变换，不过如此！</a></p>
<p>Mozilla 开发者网络（MDN）：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transforms" target="_blank" rel="external">CSS Transforms</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 在学习慕课网H5+JS+CSS3实现圣诞情缘的时候遇到css3的3D转换，虽然也学习过css3的3d变化教程，但都是基于理论上，没有自己亲自应用过，所以现在使用的时候就有点吃力。今天就重新学习了一遍css3的3D变换。&lt;/p&gt;
&lt;h3 id=&quot;一、rotateX-rotateY-rotateZ&quot;&gt;&lt;a href=&quot;#一、rotateX-rotateY-rotateZ&quot; class=&quot;headerlink&quot; title=&quot;一、rotateX, rotateY, rotateZ&quot;&gt;&lt;/a&gt;一、rotateX, rotateY, rotateZ&lt;/h3&gt;&lt;p&gt;先介绍rotateX(), rotateY(), rotateZ()这三个方法，在介绍这三个方法之前我们先来一张图：&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://fanwalker.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>初识观察者模式</title>
    <link href="http://fanwalker.com/2017/08/13/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://fanwalker.com/2017/08/13/观察者模式的理解/</id>
    <published>2017-08-13T13:23:27.000Z</published>
    <updated>2017-11-18T08:21:30.179Z</updated>
    
    <content type="html"><![CDATA[<p>在学习H5+JS+CSS3实现动画的时候接触到JavaScript设计模式之一的观察者模式，就顺便查了网上的资料，不过看了网上的一些资料，对观察者模式的应用还是有些懵懵懂懂，只是了解到观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。比如浏览器的事件也是观察者模式：</p>
<pre><code>div.onclick = function click(){
    console.log(&apos;click&apos;);
}
</code></pre><a id="more"></a>
<p>function click订阅了div的click事件，当我们的鼠标点击操作，事件发布，对应function就会执行。这个function click 就是一个观察者。即这里的DOM元素便是主体，事件处理代码便是观察者。</p>
<p>我对于观察者模式的理解也就仅限于此，对它的实现与应用还没有完全理解，下面的内容转载自<a href="http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html" target="_blank" rel="external">汤姆大叔的博客《深入理解JavaScript系列（32）：设计模式之观察者模式》</a>(对自己要求是多看几遍，慢慢理解)</p>
<h3 id="正文（版本一）"><a href="#正文（版本一）" class="headerlink" title="正文（版本一）"></a>正文（版本一）</h3><p>JS里对观察者模式的实现是通过回调来实现的，我们来先定义一个pubsub对象，其内部包含了3个方法：订阅、退订、发布。</p>
<pre><code>var pubsub = {};
(function (q) {
    var topics = {}, // 回调函数存放的数组
    subUid = -1;
    // 发布方法
    q.publish = function (topic, args) {
        if (!topics[topic]) {
            return false;
        }
        setTimeout(function () {
            var subscribers = topics[topic],
            len = subscribers ? subscribers.length : 0;
            while (len--) {
                subscribers[len].func(topic, args);
            }
        }, 0);
        return true;
    };
    //订阅方法
    q.subscribe = function (topic, func) {
        if (!topics[topic]) {
            topics[topic] = [];
        }
        var token = (++subUid).toString();
        topics[topic].push({
            token: token,
            func: func
        });
        return token;
    };
    //退订方法
    q.unsubscribe = function (token) {
        for (var m in topics) {
            if (topics[m]) {
                for (var i = 0, j = topics[m].length; i &lt; j; i++) {
                    if (topics[m][i].token === token) {
                           topics[m].splice(i, 1);
                        return token;
                    }
                }
            }
        }
        return false;
    };
} (pubsub));
</code></pre><p>使用方式如下：</p>
<pre><code>//来，订阅一个
pubsub.subscribe(&apos;example1&apos;, function (topics, data) {
    console.log(topics + &quot;: &quot; + data);
});

//发布通知
pubsub.publish(&apos;example1&apos;, &apos;hello world!&apos;);
pubsub.publish(&apos;example1&apos;, [&apos;test&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);
pubsub.publish(&apos;example1&apos;, [{ &apos;color&apos;: &apos;blue&apos; }, { &apos;text&apos;: &apos;hello&apos;}]);
</code></pre><p>怎么样？用起来是不是很爽？但是这种方式有个问题，就是没办法退订订阅，要退订的话必须指定退订的名称，所以我们再来一个版本：</p>
<pre><code>//将订阅赋值给一个变量，以便退订
var testSubscription = pubsub.subscribe(&apos;example1&apos;, function (topics, data) {
    console.log(topics + &quot;: &quot; + data);
});

//发布通知
pubsub.publish(&apos;example1&apos;, &apos;hello world!&apos;);
pubsub.publish(&apos;example1&apos;, [&apos;test&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);
pubsub.publish(&apos;example1&apos;, [{ &apos;color&apos;: &apos;blue&apos; }, { &apos;text&apos;: &apos;hello&apos;}]);

//退订
setTimeout(function () {
    pubsub.unsubscribe(testSubscription);
}, 0);

//再发布一次，验证一下是否还能够输出信息
pubsub.publish(&apos;example1&apos;, &apos;hello again! (this will fail)&apos;);
</code></pre><h3 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h3><p>我们也可以利用原型的特性实现一个观察者模式，代码如下：</p>
<pre><code>function Observer() {
    this.fns = [];
}
Observer.prototype = {
    subscribe: function (fn) {
        this.fns.push(fn);
    },
    unsubscribe: function (fn) {
        this.fns = this.fns.filter(
                        function (el) {
                            if (el !== fn) {
                                return el;
                            }
                        }
                    );
    },
    update: function (o, thisObj) {
        var scope = thisObj || window;
        this.fns.forEach(
                        function (el) {
                            el.call(scope, o);
                        }
                    );
    }
};

//测试
var o = new Observer;
var f1 = function (data) {
    console.log(&apos;Robbin: &apos; + data + &apos;, 赶紧干活了！&apos;);
};

var f2 = function (data) {
    console.log(&apos;Randall: &apos; + data + &apos;, 找他加点工资去！&apos;);
};

o.subscribe(f1);
o.subscribe(f2);

o.update(&quot;Tom回来了！&quot;)

//退订f1
o.unsubscribe(f1);
//再来验证
o.update(&quot;Tom回来了！&quot;);   
</code></pre><p>如果提示找不到filter或者forEach函数，可能是因为你的浏览器还不够新，暂时不支持新标准的函数，你可以使用如下方式自己定义：</p>
<pre><code>if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (fn, thisObj) {
        var scope = thisObj || window;
        for (var i = 0, j = this.length; i &lt; j; ++i) {
            fn.call(scope, this[i], i, this);
        }
    };
}
if (!Array.prototype.filter) {
    Array.prototype.filter = function (fn, thisObj) {
        var scope = thisObj || window;
        var a = [];
        for (var i = 0, j = this.length; i &lt; j; ++i) {
            if (!fn.call(scope, this[i], i, this)) {
                continue;
            }
            a.push(this[i]);
        }
        return a;
    };
}
</code></pre><h3 id="版本三"><a href="#版本三" class="headerlink" title="版本三"></a>版本三</h3><p>如果想让多个对象都具有观察者发布订阅的功能，我们可以定义一个通用的函数，然后将该函数的功能应用到需要观察者功能的对象上，代码如下：</p>
<pre><code>//通用代码
var observer = {
    //订阅
    addSubscriber: function (callback) {
        this.subscribers[this.subscribers.length] = callback;
    },
    //退订
    removeSubscriber: function (callback) {
        for (var i = 0; i &lt; this.subscribers.length; i++) {
            if (this.subscribers[i] === callback) {
                delete (this.subscribers[i]);
            }
        }
    },
    //发布
    publish: function (what) {
        for (var i = 0; i &lt; this.subscribers.length; i++) {
            if (typeof this.subscribers[i] === &apos;function&apos;) {
                this.subscribers[i](what);
            }
        }
    },
    // 将对象o具有观察者功能
    make: function (o) { 
        for (var i in this) {
            o[i] = this[i];
            o.subscribers = [];
        }
    }
};
</code></pre><p>然后订阅2个对象blogger和user，使用observer.make方法将这2个对象具有观察者功能，代码如下：</p>
<pre><code>var blogger = {
    recommend: function (id) {
        var msg = &apos;dudu 推荐了的帖子:&apos; + id;
        this.publish(msg);
    }
};

var user = {
    vote: function (id) {
        var msg = &apos;有人投票了!ID=&apos; + id;
        this.publish(msg);
    }
};

observer.make(blogger);
observer.make(user);
</code></pre><p>使用方法就比较简单了，订阅不同的回调函数，以便可以注册到不同的观察者对象里（也可以同时注册到多个观察者对象里）：</p>
<pre><code>var tom = {
    read: function (what) {
        console.log(&apos;Tom看到了如下信息：&apos; + what)
    }
};

var mm = {
    show: function (what) {
        console.log(&apos;mm看到了如下信息：&apos; + what)
    }
};
// 订阅
blogger.addSubscriber(tom.read);
blogger.addSubscriber(mm.show);
blogger.recommend(123); //调用发布

//退订
blogger.removeSubscriber(mm.show);
blogger.recommend(456); //调用发布

//另外一个对象的订阅
user.addSubscriber(mm.show);
user.vote(789); //调用发布
</code></pre><h3 id="jQuery版本"><a href="#jQuery版本" class="headerlink" title="jQuery版本"></a>jQuery版本</h3><p>根据jQuery1.7版新增的on/off功能，我们也可以定义jQuery版的观察者：</p>
<pre><code>(function ($) {

    var o = $({});

    $.subscribe = function () {
        o.on.apply(o, arguments);
    };

    $.unsubscribe = function () {
        o.off.apply(o, arguments);
    };

    $.publish = function () {
        o.trigger.apply(o, arguments);
    };

} (jQuery));
</code></pre><p>调用方法比上面3个版本都简单：</p>
<pre><code>//回调函数
function handle(e, a, b, c) {
    // `e`是事件对象，不需要关注
    console.log(a + b + c);
};

//订阅
$.subscribe(&quot;/some/topic&quot;, handle);
//发布
$.publish(&quot;/some/topic&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]); // 输出abc


$.unsubscribe(&quot;/some/topic&quot;, handle); // 退订

//订阅
$.subscribe(&quot;/some/topic&quot;, function (e, a, b, c) {
    console.log(a + b + c);
});

$.publish(&quot;/some/topic&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]); // 输出abc

//退订（退订使用的是/some/topic名称，而不是回调函数哦，和版本一的例子不一样
$.unsubscribe(&quot;/some/topic&quot;); 
</code></pre><p>可以看到，他的订阅和退订使用的是字符串名称，而不是回调函数名称，所以即便传入的是匿名函数，我们也是可以退订的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习H5+JS+CSS3实现动画的时候接触到JavaScript设计模式之一的观察者模式，就顺便查了网上的资料，不过看了网上的一些资料，对观察者模式的应用还是有些懵懵懂懂，只是了解到观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。比如浏览器的事件也是观察者模式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;div.onclick = function click(){
    console.log(&amp;apos;click&amp;apos;);
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://fanwalker.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>nodejs爬虫学习</title>
    <link href="http://fanwalker.com/2017/08/12/nodejs%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
    <id>http://fanwalker.com/2017/08/12/nodejs爬虫学习/</id>
    <published>2017-08-12T00:08:21.000Z</published>
    <updated>2017-11-18T08:21:12.356Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是记录在学习nodejs爬虫时学到的知识。学习过程主要是参照了这篇文章：<br><a href="https://github.com/chokcoco/cnblogsArticle/issues/7" title="【nodeJS爬虫】前端爬虫系列 -- 小爬「博客园」" target="_blank" rel="external">https://github.com/chokcoco/cnblogsArticle/issues/7</a>，文章中对爬虫讲的很详细，对想要学习爬虫的同学会有帮助。</p>
<h3 id="一、superagent"><a href="#一、superagent" class="headerlink" title="一、superagent"></a>一、superagent</h3><p>superagent是一款极好用的轻量级的更为优化的ajax API同时是nodejs模块，它专注于处理服务端/客户端的http请求，让你处理get,post,put,delete,head请求时更轻松。虽然有内置的http等模块进行请求的处理，但superagent更简单。来看看它们之间的对比：<br><a id="more"></a><br>    var request = require(‘superagent’);<br>    var http = require(‘http’);<br>    var queryString = require(‘queryString’);</p>
<p>使用superagent：</p>
<pre><code>request
    .post(&apos;/api/pet&apos;)
    .send({ name: &apos;Manny&apos;, species: &apos;cat&apos; })
    .set(&apos;X-API-Key&apos;, &apos;foobar&apos;)
    .set(&apos;Accept&apos;, &apos;application/json&apos;)
    .end(function(err, res){
        if (res.ok) {
            alert(&apos;yay got &apos; + JSON.stringify(res.body));
        } else {
            alert(&apos;Oh no! error &apos; + res.text);
        }
    });
</code></pre><p>使用http：</p>
<pre><code>var postData = queryString.stringify({name: &apos;Manny&apos;, species:&apos;cat&apos;});
var options = {
    path: &apos;/api/pet&apos;,
    method: &apos;POST&apos;,
    headers: {
        &apos;X-API-Key&apos;: &apos;foobar&apos;,
        &apos;Accept&apos;: &apos;application/json&apos;
            }
    };

var req = http.request(options, function (res) {
    res.on(&apos;data&apos;, function (chunk) {
        console.log(chunk);
    });
});

req.on(&apos;error&apos;, function (err) {
    console.log(err);
});
req.write(postData);
req.end();
</code></pre><p>从对比中可以发现superagent是链式操作的，用起来比http更方便，代码更容易读懂。更详细的使用请参考superagent官方文档：<a href="https://visionmedia.github.io/superagent/" title="superagent" target="_blank" rel="external">https://visionmedia.github.io/superagent/</a>，中文使用文档：<a href="https://cnodejs.org/topic/5378720ed6e2d16149fa16bd" title="superagent中文使用文档" target="_blank" rel="external">https://cnodejs.org/topic/5378720ed6e2d16149fa16bd</a></p>
<h3 id="二、cheerio"><a href="#二、cheerio" class="headerlink" title="二、cheerio"></a>二、cheerio</h3><p>通过cheerio.load()方法获得一个实现了jQuery接口的变量，比如：</p>
<pre><code>var cheerio = require(&apos;cheerio&apos;),
//习惯性地将它命名为 `$`
$ = cheerio.load(&apos;&lt;h2 class=&quot;title&quot;&gt;Hello world&lt;/h2&gt;&apos;);

$(&apos;h2.title&apos;).text(&apos;Hello there!&apos;);
$(&apos;h2&apos;).addClass(&apos;welcome&apos;);
</code></pre><p>load()方法的参数可以是html里面的内容，也可以是整个html，调用完这个方法后你就可以利用 $ 使用 jquery 的语法了，官方文档：<a href="https://github.com/cheeriojs/cheerio" title="cheerio" target="_blank" rel="external">https://github.com/cheeriojs/cheerio</a> 。</p>
<h3 id="三、eventproxy"><a href="#三、eventproxy" class="headerlink" title="三、eventproxy"></a>三、eventproxy</h3><p>使用eventproxy来控制并发。假设你要并发异步获取两三个地址的数据，并且要在获取到数据之后，对这些数据一起进行利用的话，常规的写法是自己维护一个计数器。</p>
<p>先定义一个 var count = 0，然后每次抓取成功以后，就 count++。如果你是要抓取三个源的数据，由于你根本不知道这些异步操作到底谁先完成，那么每次当抓取成功的时候，就判断一下 count === 3。当值为真时，使用另一个函数继续完成操作。</p>
<p>而 eventproxy 就起到了这个计数器的作用，它来帮你管理到底这些异步操作是否完成，完成之后，它会自动调用你提供的处理函数，并将抓取到的数据当参数传过来。</p>
<p>一般我们写的计数器：</p>
<pre><code>(function () {
  var count = 0;
  var result = {};

  $.get(&apos;http://data1_source&apos;, function (data) {
    result.data1 = data;
    count++;
    handle();
    });
  $.get(&apos;http://data2_source&apos;, function (data) {
    result.data2 = data;
    count++;
    handle();
    });
  $.get(&apos;http://data3_source&apos;, function (data) {
    result.data3 = data;
    count++;
    handle();
    });

  function handle() {
    if (count === 3) {
          var html = fuck(result.data1, result.data2, result.data3);
          render(html);
        }
      }
})();
</code></pre><p>使用eventproxy：</p>
<pre><code>var ep = new eventproxy();
ep.all(&apos;data1_event&apos;, &apos;data2_event&apos;, &apos;data3_event&apos;, function (data1, data2, data3) {
  var html = fuck(data1, data2, data3);
  render(html);
});

$.get(&apos;http://data1_source&apos;, function (data) {
  ep.emit(&apos;data1_event&apos;, data);
  });

$.get(&apos;http://data2_source&apos;, function (data) {
  ep.emit(&apos;data2_event&apos;, data);
  });

$.get(&apos;http://data3_source&apos;, function (data) {
  ep.emit(&apos;data3_event&apos;, data);
  });
</code></pre><p>ep.all(‘data1_event’, ‘data2_event’, ‘data3_event’, function (data1, data2, data3) {});</p>
<p>这一句，监听了三个事件，分别是 data1_event, data2_event, data3_event，每次当一个源的数据抓取完成时，就通过 ep.emit() 来告诉 ep 自己，某某事件已经完成了。</p>
<p>当三个事件未同时完成时，ep.emit() 调用之后不会做任何事；当三个事件都完成的时候，就会调用末尾的那个回调函数，来对它们进行统一处理。</p>
<h3 id="四、async"><a href="#四、async" class="headerlink" title="四、async"></a>四、async</h3><p>使用 async 控制异步并发数量，在这个爬虫中要获取4000个URL，一个网站很容易被单IP的巨量 URL 请求攻击到崩溃，别的网站也有可能会因为你发出的并发连接数太多而当你是在恶意请求，把你的 IP 封掉，所以这里使用async 控制异步并发数量，下面展示async使用示例：</p>
<pre><code>var async = require(&quot;async&quot;);

// 并发连接数的计数器
var concurrencyCount = 0;
var fetchUrl = function (url, callback) {
  // delay 的值在 2000 以内，是个随机的整数
  var delay = parseInt((Math.random() * 10000000) % 2000, 10);
  concurrencyCount++;
  console.log(&apos;现在的并发数是&apos;, concurrencyCount, &apos;，正在抓取的是&apos;, url, &apos;，耗时&apos; + delay + &apos;毫秒&apos;);
  setTimeout(function () {
    concurrencyCount--;
    callback(null, url + &apos; html content&apos;);
  }, delay);
};

//伪造一组链接
var urls = [];
for(var i = 0; i &lt; 30; i++) {
  urls.push(&apos;http://datasource_&apos; + i);
}

async.mapLimit(urls, 5, function (url, callback) {
  fetchUrl(url, callback);
}, function (err, result) {
  console.log(&apos;final:&apos;);
  console.log(result);
});
</code></pre><h3 id="五、事件轮询机制"><a href="#五、事件轮询机制" class="headerlink" title="五、事件轮询机制"></a>五、事件轮询机制</h3><p>我们来看一组代码</p>
<pre><code>var http = require(&quot;http&quot;);

function onRequest(request, response) {
  console.log(&quot;Request received.&quot;);
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;Hello World&quot;);
  response.end();
}

http.createServer(onRequest).listen(8888);

console.log(&quot;Server has started.&quot;);
</code></pre><p>类似于上面的代码：</p>
<pre><code>var http = require(&quot;http&quot;);

http.createServer(function(request, response) {
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.write(&quot;Hello World&quot;);
  response.end();
}).listen(8888);
</code></pre><p>Node.js的事件循环是靠一个单线程不断地查询队列中是否有事件，当它读取到一个事件时，将调用与这个事件关联的javascript函数，如果这个函数是执行一个IO操作，比如侦听一下8888端口是否有Scoket链接，Node.js会启动这个IO操作，但是不会等待IO操作结束，而是继续到队列中查看是否有下一个事件，如果有，就处理这个事件。</p>
<p>下面关键来了，花开两朵，各表一枝，那么最好还是要会合的，nodejs如何知道启动的IO操作是否执行，执行的结果如何呢？比如发现我们浏览器访问8888端口，这时IO操作侦听到一个请求，那么下一步应该执行上面的onRequest了，但是Nodejs管理的CPU正在做其他事情啊。</p>
<p>这里，IO操作结束后会自己将一个执行原始回调函数的引用加入到事件队列中，也就是onRequest这个函数加入到事件队列中，NodeJS因为一直在轮询这个事件队列，会发现这个事件，执行事件的函数onRequest，完成用户的处理。</p>
<p>我们前后两个代码，一个是将函数体代码写入http，另外一个是用onRequest替代这部分代码，这个onRequest很重要，可以作为一个事件放入事件队列中，而函数体这段代码是无法放入事件队列中的，而且无法被另外一个函数调用。</p>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p>《好用的 HTTP模块SuperAgent》：<a href="http://www.jianshu.com/p/98b854322260" title="好用的 HTTP模块SuperAgent" target="_blank" rel="external">http://www.jianshu.com/p/98b854322260</a></p>
<p>《使用 eventproxy 控制并发》：<a href="https://github.com/alsotang/node-lessons/tree/master/lesson4" title="《使用 eventproxy 控制并发》" target="_blank" rel="external">https://github.com/alsotang/node-lessons/tree/master/lesson4</a></p>
<p>《使用 async 控制并发》：<a href="https://github.com/alsotang/node-lessons/tree/master/lesson5" title="《使用 async 控制并发》" target="_blank" rel="external">https://github.com/alsotang/node-lessons/tree/master/lesson5</a></p>
<p>《NodeJs入门之事件驱动》：<a href="http://www.jdon.com/idea/nodejs/tutorial.html" title="NodeJs入门之事件驱动" target="_blank" rel="external">http://www.jdon.com/idea/nodejs/tutorial.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是记录在学习nodejs爬虫时学到的知识。学习过程主要是参照了这篇文章：&lt;br&gt;&lt;a href=&quot;https://github.com/chokcoco/cnblogsArticle/issues/7&quot; title=&quot;【nodeJS爬虫】前端爬虫系列 -- 小爬「博客园」&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/chokcoco/cnblogsArticle/issues/7&lt;/a&gt;，文章中对爬虫讲的很详细，对想要学习爬虫的同学会有帮助。&lt;/p&gt;
&lt;h3 id=&quot;一、superagent&quot;&gt;&lt;a href=&quot;#一、superagent&quot; class=&quot;headerlink&quot; title=&quot;一、superagent&quot;&gt;&lt;/a&gt;一、superagent&lt;/h3&gt;&lt;p&gt;superagent是一款极好用的轻量级的更为优化的ajax API同时是nodejs模块，它专注于处理服务端/客户端的http请求，让你处理get,post,put,delete,head请求时更轻松。虽然有内置的http等模块进行请求的处理，但superagent更简单。来看看它们之间的对比：&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://fanwalker.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>DOM学习</title>
    <link href="http://fanwalker.com/2017/08/10/DOM%E5%AD%A6%E4%B9%A0/"/>
    <id>http://fanwalker.com/2017/08/10/DOM学习/</id>
    <published>2017-08-10T04:46:45.000Z</published>
    <updated>2017-11-18T08:20:48.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、节点层次"><a href="#一、节点层次" class="headerlink" title="一、节点层次"></a>一、节点层次</h3><p> &nbsp;&nbsp;&nbsp;节点分为几种不同的类型，每种类型分别表示文档中不同的信息及标记,节点之间的关系构成了层次，文档节点是每个文档的根节点。节点之间的关系：<br><img src="http://i.imgur.com/2wKDqZc.png" alt=""></p>
<a id="more"></a>
<h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><p>常用的方法有:</p>
<p>1、appendChild()：向childNodes列表的末尾添加一个节点，参数为要插入的节点，返回新增的节点；<br></p>
<pre><code>var returnedNode = someNode.appendChild(newNode);
alert(returnedNode == newNode);  //true
alert(someNode.lastChild == newNode); //true
</code></pre><p>2、insertBefore()：把节点放在childNodes列表中某个特定的位置上，接受两个参数：要插入的节点和作为参照的节点，如果参照节点是null，则与appendChild()执行效果相同；<br></p>
<pre><code>//插入后成为最后一个子节点
var returnedNode = someNode.insertBefore(newNode,null);
alert(newNode == someNode.lastChild); //true

//插入后成为第一个子节点
var returnedNode = someNode.insertBefore(newNode,someNode.firstChild);
alert(returnedNode == newNode); //true
alert(newNode == someNode.firstChild); //true
</code></pre><p>3、replaceChild()：替换节点，接受两个参数：要插入的节点和要替换的节点，要替换的节点将会被这个方法从这个文档树中移除，但被替换的节点还在文档中，只是在文档中已经没有了自己的位置；<br></p>
<pre><code>//替换第一个节点
var returnedNode = someNode.replaceChild(newNode,someNode.firstChild);
</code></pre><p>4、removeChild()：移除节点，接受参数为要移除的节点；</p>
<pre><code>//移除第一个子节点
var returnedNode = someNode.removeChild(someNode.firstChild);
alert(returnedNode == someNode.firstChild); //true
</code></pre><h4 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h4><p>JavaScript通过Document类型表示文档，document对象是HTMLDocument的一个实例，HTMLDocument继承自Document类型，在浏览器中document对象表示整个HTML页面，document对象是window对象的一个属性，可以作为全局对象访问。</p>
<p><strong>查找元素</strong></p>
<p>getElementById()：接受一个参数:要取得元素id，区分大小写：</p>
<pre><code>&lt;div id=&quot;mydiv&quot;&gt;Some text&lt;/div&gt;
</code></pre><p>取得这个元素</p>
<pre><code>var div = document.getElementById(&quot;mydiv&quot;);
</code></pre><p>getElementsByTagName()：接受一个参数：要取得的元素标签名：</p>
<pre><code>var images = document.getElementsByTagName(&quot;img&quot;);

alert(images.length);//输出图像的数量

alert(images[0].src);//输出第一个图像的src特性
</code></pre><p>getElementsByName()：接受一个参数：要取得的元素的name特性：</p>
<pre><code>&lt;div name=&quot;color&quot;&gt;Some text1&lt;/div&gt;

&lt;div name=&quot;color&quot;&gt;Some text2&lt;/div&gt;

&lt;div name=&quot;color&quot;&gt;Some text3&lt;/div&gt;
</code></pre><p>取得“name=color”的元素：</p>
<pre><code>var divs = document.getElementsByName(&quot;color&quot;);
</code></pre><h4 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h4><p>Element类型可以理解为HTML元素，提供了元素标签名、子节点及特性的访问。</p>
<p>HTML元素常用的特性有:id、title、className</p>
<p>可以使用getAttribute()、setAttribute()和removeAttribute()方法操作元素特性，如：getAttribute(“id”)、setAttribute(“id”)、removeAttribute(“id”)</p>
<p>使用document.createElement()创建元素，接受一个参数：要创建的元素的标签名，如：<br>    var div = document.createElement(“div”);</p>
<h4 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h4><p>Text类型表示文本节点，创建文本节点：</p>
<pre><code>var element = document.createElement(&quot;div&quot;);
element.className = &quot;message&quot;;&lt;br&gt;
var textNode = document.createTextNode(&quot;Hello World&quot;);
element.appendChild(textNode);&lt;br&gt;
document.body.appendChild(element);
</code></pre><h3 id="二、Dom操作技术"><a href="#二、Dom操作技术" class="headerlink" title="二、Dom操作技术"></a>二、Dom操作技术</h3><h4 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h4><p>创建动态脚本有两种方法：</p>
<p>1：插入外部JavaScript文件</p>
<pre><code>&lt;script type-&quot;text/javascript&quot; src=&quot;client.js&quot;&gt;&lt;/script&gt;
</code></pre><p>相应的DOM代码：</p>
<pre><code>var script = document.createElement(&quot;script&quot;);
script.type = &quot;text/jacascript&quot;;
script.src = &quot;client.js&quot;;
document.body.appendChild(script);
</code></pre><p>2：直接插入JavaScript代码：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
 function sayHi(){
    alert(&quot;hi&quot;);}
&lt;/script&gt;
</code></pre><h4 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h4><p>页面加载完成后动态的将样式加载到页面中：</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot;&gt;
</code></pre><p>相应的DOM代码：</p>
<pre><code>var link = document.createElement(&quot;link&quot;);
link.rel = &quot;stylesheet&quot;;
link.type = &quot;text/css&quot;;
link.href = &quot;style.css&quot;;
var head = document.getElementsByTagName(&quot;head&quot;)[0];
head.appendChild(link);
</code></pre><p>直接插入样式：<br>    <style type="text/css"><br>        body{<br>        font-size:14px;<br>        }<br>    </style></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h4><p>最基本的节点类型：Node，所有其他类型都继承自Node；<br>Document类型表示整个文档，document对象是Document的一个实例，使用document对象，有很多种方式可以查询和取得节点<br><br>Element节点可以用来操作HTML元素或XML元素的内容和特性。<br>DOM操作是JavaScript程序中开销最大的部分，而访问NodeList导致的问题最多，NodeList对象都是“动态的”，每次访问NodeList对象都会运行一次查询，所以，尽量减少DOM操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、节点层次&quot;&gt;&lt;a href=&quot;#一、节点层次&quot; class=&quot;headerlink&quot; title=&quot;一、节点层次&quot;&gt;&lt;/a&gt;一、节点层次&lt;/h3&gt;&lt;p&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;节点分为几种不同的类型，每种类型分别表示文档中不同的信息及标记,节点之间的关系构成了层次，文档节点是每个文档的根节点。节点之间的关系：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/2wKDqZc.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="http://fanwalker.com/tags/html/"/>
    
      <category term="JavaScript" scheme="http://fanwalker.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
